{"version":3,"file":"static/js/3242.63748b15.chunk.js","mappings":"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GACN,SAAM,eACN,WAAM,6IACN,SAAM,+JACN,IAAM,eACN,WAAM,+GACN,WAAM,SACN,SAAM,uRACN,WAAM,+DACN,WAAM,6CACN,SAAM,qEACN,YAAO,2EACP,UAAO,eACP,YAAO,mDACP,UAAO,iFACP,UAAK,iFACL,QAAK,qBACL,UAAK,qKACL,QAAK,6yBACL,YAAO,qKACP,YAAO,6FACP,UAAO,iLACP,YAAO,mSACP,UAAO,SACP,YAAO,6CACP,UAAO,qBACP,WAAM,yDACN,SAAM,mDACN,WAAM,SACN,SAAM,eACN,WAAM,mMACN,WAAM,GACN,SAAM,iFACN,YAAO,6FACP,YAAO,qKACP,UAAO,+GACP,GAAK,qBACL,UAAK,uLACL,QAAK,6aACL,UAAK,qBACL,QAAK,6CACL,UAAK,qEACL,QAAK,qBACL,UAAK,6CACL,QAAK,iLACL,UAAK,qBACL,UAAK,eACL,QAAK,eACL,WAAM,eACN,SAAM,6CACN,WAAM,iFACN,SAAM,iCACN,WAAM,iFACN,SAAM,+DACN,WAAM,mDACN,SAAM,iFACN,YAAO,iIACP,UAAO,2BACP,UAAO,SACP,WAAM,qBACN,SAAM,iFACN,WAAM,6CACN,SAAM,2BACN,QAAK,+JACL,WAAM,uCACN,SAAM,iCACN,YAAO,SACP,UAAO,6CACP,UAAO,SACP,UAAK,2EACL,QAAK,iLACL,UAAK,mDACL,QAAK,iFACL,YAAO,iOACP,UAAO,yJACP,YAAO,GACP,UAAO,qBACP,WAAM,GACN,SAAM,GACN,WAAM,GACN,SAAM,6CACN,UAAK,mDACL,QAAK,eACL,UAAK,SACL,QAAK,uIACL,YAAO,mDACP,UAAO,6CACP,UAAO,yDACP,WAAM,mGACN,WAAM,iCACN,SAAM,uLACN,WAAM,6CACN,SAAM,iCACN,WAAM,eACN,SAAM,qBACN,WAAM,6CACN,SAAM,iFACN,WAAM,SACN,SAAM,yGACN,WAAM,+GACN,SAAM,+GACN,WAAM,2BACN,SAAM,qEACN,YAAO,2BACP,UAAO,6CACP,YAAO,SACP,UAAO,uCACP,YAAO,2EACP,UAAO,2TACP,YAAO,qNACP,UAAO,uFACP,aAAQ,+G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O,mDACP,UAAO,yVACP,YAAO,mDACP,UAAO,uCACP,WAAM,6CACN,SAAM,SACN,SAAM,yMACN,WAAM,iCACN,SAAM,mDACN,WAAM,GACN,SAAM,iFACN,WAAM,+DACN,SAAM,GACN,YAAO,GACP,UAAO,qEACP,YAAO,iCACP,UAAO,2BACP,SAAM,yDACN,WAAM,iCACN,SAAM,2BACN,QAAK,SACL,UAAK,eACL,QAAK,qBACL,SAAM,2EACN,WAAM,2EACN,SAAM,uOACN,YAAO,SACP,UAAO,iCACP,QAAK,yDACL,UAAO,2QACP,YAAO,6CACP,UAAO,eACP,SAAM,6IACN,WAAM,SACN,SAAM,2BACN,UAAK,SACL,QAAK,+MACL,UAAK,uCACL,QAAK,2EACL,UAAO,qBACP,YAAO,6FACP,UAAO,SACP,SAAM,iCACN,WAAM,mDACN,SAAM,mGACN,SAAM,SACN,WAAM,GACN,SAAM,6CACN,SAAM,eACN,SAAM,mGACN,GAAK,GACL,UAAK,SACL,UAAK,mDACL,QAAK,6FACL,WAAM,+DACN,WAAM,SACN,SAAM,2BACN,IAAM,SACN,WAAM,2EACN,WAAM,2EACN,SAAM,2BACN,YAAO,2BACP,YAAO,6CACP,UAAO,SACP,WAAM,mGACN,WAAM,qBACN,SAAM,6CACN,UAAK,SACL,QAAK,6OACL,WAAM,2BACN,WAAM,GACN,YAAO,eACP,UAAO,GACP,UAAK,2TACL,QAAK,GACL,UAAK,eACL,QAAK,mSACL,YAAO,uIACP,UAAO,GACP,YAAO,uFACP,UAAO,qEACP,WAAM,qKACN,WAAM,iFACN,SAAM,iCACN,UAAK,qEACL,QAAK,eACL,UAAK,GACL,QAAK,qWACL,YAAO,qBACP,YAAO,eACP,UAAO,iCACP,WAAM,2HACN,SAAM,mDACN,WAAM,qBACN,SAAM,2NACN,WAAM,2EACN,WAAM,qEACN,SAAM,SACN,WAAM,2HACN,SAAM,GACN,WAAM,iIACN,SAAM,qBACN,WAAM,mMACN,SAAM,SACN,WAAM,eACN,SAAM,yGACN,YAAO,uCACP,YAAO,SACP,UAAO,qBACP,YAAO,+PACP,UAAO,GACP,YAAO,2EACP,UAAO,y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CAAC,cACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,eACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,eACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,eACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,eACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,eACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,eACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,SACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,gBACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,gBACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,eACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,eACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,eACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,eACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,UACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAAC,CAAC,aACP,SAAK,CAAC,CAAC,cACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,WACP,SAAK,CAAC,CAAC,YACP,SAAK,CAA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","sources":["../../../node_modules/redux/es/redux.js","../../../node_modules/@rematch/core/src/reduxStore.ts","../../../node_modules/@rematch/core/src/validate.ts","../../../node_modules/@rematch/core/src/dispatcher.ts","../../../node_modules/@rematch/core/src/bag.ts","../../../node_modules/@rematch/core/src/rematchStore.ts","../../../node_modules/@rematch/core/src/config.ts","../../../node_modules/@rematch/core/src/index.ts","../../../node_modules/@remix-run/router/history.ts","../../../node_modules/@remix-run/router/utils.ts","../../../node_modules/@remix-run/router/router.ts","../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js","../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js","../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js","../../../node_modules/pinyin/data/compound_surname.js","../../../node_modules/pinyin/data/dict-zi-web.js","../../../node_modules/pinyin/data/surname.js","../../../node_modules/pinyin/lib/phonetic-symbol.js","../../../node_modules/pinyin/lib/pinyin.js","../../../node_modules/pinyin/lib/util.js","../../../node_modules/pinyin/lib/web-pinyin.js","../../../node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js","../../../node_modules/react-redux/es/hooks/useSelector.js","../../../node_modules/react-redux/es/utils/batch.js","../../../node_modules/react-redux/es/index.js","../../index.tsx","../../dom.ts","../../lib/use-sync-external-store-shim/useSyncExternalStoreShimClient.ts","../../lib/use-sync-external-store-shim/index.ts","../../lib/context.ts","../../lib/hooks.tsx","../../lib/components.tsx","../../../packages/basic-layouts/node_modules/classnames/index.js","../../../../packages/react-router/index.tsx","../../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../../../node_modules/@babel/runtime/helpers/iterableToArray.js","../../../node_modules/@babel/runtime/helpers/nonIterableSpread.js","../../../node_modules/@babel/runtime/helpers/toConsumableArray.js"],"sourcesContent":["import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';\n\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */\nfunction formatProdErrorMessage(code) {\n  return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + 'use the non-minified dev environment for full errors. ';\n}\n\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = (function () {\n  return typeof Symbol === 'function' && Symbol.observable || '@@observable';\n})();\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar randomString = function randomString() {\n  return Math.random().toString(36).substring(7).split('').join('.');\n};\n\nvar ActionTypes = {\n  INIT: \"@@redux/INIT\" + randomString(),\n  REPLACE: \"@@redux/REPLACE\" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n  }\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nfunction miniKindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n  var type = typeof val;\n\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'symbol':\n    case 'function':\n      {\n        return type;\n      }\n  }\n\n  if (Array.isArray(val)) return 'array';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  var constructorName = ctorName(val);\n\n  switch (constructorName) {\n    case 'Symbol':\n    case 'Promise':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Map':\n    case 'Set':\n      return constructorName;\n  } // other\n\n\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n}\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction kindOf(val) {\n  var typeOfVal = typeof val;\n\n  if (process.env.NODE_ENV !== 'production') {\n    typeOfVal = miniKindOf(val);\n  }\n\n  return typeOfVal;\n}\n\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(0) : 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');\n  }\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(1) : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(2) : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n  /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(3) : 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(4) : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n    }\n\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(5) : 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(6) : 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n      currentListeners = null;\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(7) : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(8) : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n    }\n\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(9) : 'Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(10) : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n    }\n\n    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(11) : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n/**\n * Creates a Redux store that holds the state tree.\n *\n * **We recommend using `configureStore` from the\n * `@reduxjs/toolkit` package**, which replaces `createStore`:\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\nvar legacy_createStore = createStore;\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return \"The \" + argumentName + \" has unexpected type of \\\"\" + kindOf(inputState) + \"\\\". Expected argument to be an object with the following \" + (\"keys: \\\"\" + reducerKeys.join('\", \"') + \"\\\"\");\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return \"Unexpected \" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \" \" + (\"\\\"\" + unexpectedKeys.join('\", \"') + \"\\\" found in \" + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + (\"\\\"\" + reducerKeys.join('\", \"') + \"\\\". Unexpected keys will be ignored.\");\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(12) : \"The slice reducer for key \\\"\" + key + \"\\\" returned undefined during initialization. \" + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\n    }\n\n    if (typeof reducer(undefined, {\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\n    }) === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(13) : \"The slice reducer for key \\\"\" + key + \"\\\" returned undefined when probed with a random type. \" + (\"Don't try to handle '\" + ActionTypes.INIT + \"' or other actions in \\\"redux/*\\\" \") + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\n    }\n  });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\n\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(\"No reducer provided for key \\\"\" + key + \"\\\"\");\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n  // keys multiple times.\n\n  var unexpectedKeyCache;\n\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError;\n\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination(state, action) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey === 'undefined') {\n        var actionType = action && action.type;\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(14) : \"When called with an action of type \" + (actionType ? \"\\\"\" + String(actionType) + \"\\\"\" : '(unknown type)') + \", the slice reducer for key \\\"\" + _key + \"\\\" returned undefined. \" + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\");\n      }\n\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(16) : \"bindActionCreators expected an object or a function, but instead received: '\" + kindOf(actionCreators) + \"'. \" + \"Did you write \\\"import ActionCreators from\\\" instead of \\\"import * as ActionCreators from\\\"?\");\n  }\n\n  var boundActionCreators = {};\n\n  for (var key in actionCreators) {\n    var actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n\n  return boundActionCreators;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n\n      var _dispatch = function dispatch() {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(15) : 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(void 0, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\n      return _objectSpread(_objectSpread({}, store), {}, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\n\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning('You are currently using minified code outside of NODE_ENV === \"production\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexport { ActionTypes as __DO_NOT_USE__ActionTypes, applyMiddleware, bindActionCreators, combineReducers, compose, createStore, legacy_createStore };\n","import * as Redux from 'redux'\nimport {\n\tAction,\n\tConfigRedux,\n\tModelReducers,\n\tNamedModel,\n\tRematchBag,\n\tDevtoolOptions,\n\tModels,\n\tRematchRootState,\n} from './types'\n\n/**\n * Creates 'combined' reducer for each model and then merges those reducers\n * together into a 'root' reducer. It then creates a Redux store with\n * middlewares and enhancers.\n */\nexport default function createReduxStore<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tRootState = RematchRootState<TModels, TExtraModels>\n>(bag: RematchBag<TModels, TExtraModels>): Redux.Store<RootState> {\n\tbag.models.forEach((model) => createModelReducer(bag, model))\n\n\tconst rootReducer = createRootReducer<RootState, TModels, TExtraModels>(bag)\n\n\tconst middlewares = Redux.applyMiddleware(...bag.reduxConfig.middlewares)\n\tconst enhancers = bag.reduxConfig.devtoolComposer\n\t\t? bag.reduxConfig.devtoolComposer(...bag.reduxConfig.enhancers, middlewares)\n\t\t: composeEnhancersWithDevtools(bag.reduxConfig.devtoolOptions)(\n\t\t\t\t...bag.reduxConfig.enhancers,\n\t\t\t\tmiddlewares\n\t\t  )\n\n\tconst createStore = bag.reduxConfig.createStore || Redux.createStore\n\tconst bagInitialState = bag.reduxConfig.initialState\n\tconst initialState = bagInitialState === undefined ? {} : bagInitialState\n\n\treturn createStore<RootState, Action, any, typeof initialState>(\n\t\trootReducer,\n\t\tinitialState,\n\t\tenhancers\n\t)\n}\n\n/**\n * Creates a combined reducer for a given model. What it means is that:\n * - it forms an action name for each model's reducer as 'modelName/reducerKey'\n * - it creates a mapping from action name to its reducer\n * - it wraps the mapping with a function (combined reducer) that selects and\n *   runs a reducer based on the incoming action\n * - if the model also has a base reducer defined, it creates a function which\n *   first runs the incoming action through this reducer and then passes the\n *   resulting state and the same action to combined reducer\n *\n * The final result - a function, is returned.\n */\nexport function createModelReducer<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTState extends NamedModel<TModels>['state'] = any\n>(bag: RematchBag<TModels, TExtraModels>, model: NamedModel<TModels>): void {\n\tconst modelReducers: ModelReducers<TState> = {}\n\n\t// build action name for each reducer and create mapping from name to reducer\n\tconst modelReducerKeys = Object.keys(model.reducers)\n\tmodelReducerKeys.forEach((reducerKey) => {\n\t\tconst actionName = isAlreadyActionName(reducerKey)\n\t\t\t? reducerKey\n\t\t\t: `${model.name}/${reducerKey}`\n\n\t\tmodelReducers[actionName] = model.reducers[reducerKey]\n\t})\n\n\t// select and run a reducer based on the incoming action\n\tconst combinedReducer = (\n\t\tstate: TState = model.state,\n\t\taction: Action\n\t): TState => {\n\t\tif (action.type in modelReducers) {\n\t\t\treturn modelReducers[action.type](\n\t\t\t\tstate,\n\t\t\t\taction.payload,\n\t\t\t\taction.meta\n\t\t\t\t// we use augmentation because a reducer can return void due immer plugin,\n\t\t\t\t// which makes optional returning the reducer state\n\t\t\t) as TState\n\t\t}\n\n\t\treturn state\n\t}\n\n\tconst modelBaseReducer = model.baseReducer\n\n\t// when baseReducer is defined, run the action first through it\n\tlet reducer = !modelBaseReducer\n\t\t? combinedReducer\n\t\t: (state: TState = model.state, action: Action): TState =>\n\t\t\t\tcombinedReducer(modelBaseReducer(state, action), action)\n\n\tbag.forEachPlugin('onReducer', (onReducer) => {\n\t\treducer = onReducer(reducer, model.name, bag) || reducer\n\t})\n\n\tbag.reduxConfig.reducers[model.name] = reducer\n}\n\n/**\n * It merges all reducers in config using mergeReducers function. Additionally,\n * if user supplied any rootReducers, a wrapper function around merged reducers\n * is created. It first feeds each into its corresponding 'root' reducer (if\n * it's available), and then passes on the resulting state to the merged reducer.\n */\nexport function createRootReducer<\n\tTRootState,\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(bag: RematchBag<TModels, TExtraModels>): Redux.Reducer<TRootState, Action> {\n\tconst { rootReducers } = bag.reduxConfig\n\tconst mergedReducers = mergeReducers<TRootState>(bag.reduxConfig)\n\tlet rootReducer = mergedReducers\n\n\tif (rootReducers && Object.keys(rootReducers).length) {\n\t\trootReducer = (\n\t\t\tstate: TRootState | undefined,\n\t\t\taction: Action\n\t\t): TRootState => {\n\t\t\tconst actionRootReducer = rootReducers[action.type]\n\n\t\t\tif (actionRootReducer) {\n\t\t\t\treturn mergedReducers(actionRootReducer(state, action), action)\n\t\t\t}\n\n\t\t\treturn mergedReducers(state, action)\n\t\t}\n\t}\n\n\tbag.forEachPlugin('onRootReducer', (onRootReducer) => {\n\t\trootReducer = onRootReducer(rootReducer, bag) || rootReducer\n\t})\n\n\treturn rootReducer\n}\n\n/**\n * Merges all reducers defined in config into one function using user supplied\n * or default combineReducers function.\n * If there are no reducers defined, it returns a function that just returns\n * the state for all incoming actions.\n */\nfunction mergeReducers<TRootState>(\n\treduxConfig: ConfigRedux<TRootState>\n): Redux.Reducer<TRootState, Action> {\n\tconst combineReducers = reduxConfig.combineReducers || Redux.combineReducers\n\n\tif (!Object.keys(reduxConfig.reducers).length) {\n\t\treturn (state: any): TRootState => state\n\t}\n\n\treturn combineReducers(reduxConfig.reducers as Redux.ReducersMapObject)\n}\n\n/**\n * Returns Redux Devtools compose method unless it's disabled, in which case it\n * returns default Redux.compose.\n */\nfunction composeEnhancersWithDevtools(\n\tdevtoolOptions: DevtoolOptions = {}\n): (...args: any[]) => Redux.StoreEnhancer {\n\treturn !devtoolOptions.disabled &&\n\t\ttypeof window === 'object' &&\n\t\twindow.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n\t\t? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(devtoolOptions)\n\t\t: Redux.compose\n}\n\n/**\n * Determines if a reducer key is already an action name, for example -\n * a listener on another model.\n */\nfunction isAlreadyActionName(reducerKey: string): boolean {\n\treturn reducerKey.indexOf('/') > -1\n}\n","import {\n\tConfig,\n\tModelEffects,\n\tModelReducers,\n\tNamedModel,\n\tPlugin,\n\tModels,\n} from './types'\n\n/**\n * If the first item is true, it means there is an error described by\n * the second item.\n */\nexport type Validation = [boolean | undefined, string]\n\n/**\n * Checks if a parameter is a valid object.\n */\nexport const isObject = <T>(obj: T): boolean =>\n\ttypeof obj === 'object' && obj !== null && !Array.isArray(obj)\n\n/**\n * Checks if a parameter is a valid function but only when it's defined.\n * Otherwise, always returns true.\n */\nexport const ifDefinedIsFunction = <T>(func: T): boolean =>\n\t!func || typeof func === 'function'\n\n/**\n * Takes an array of arrays of validations. Collects all errors and throws.\n * Should be used by plugins to keep the validation behaviour the same for all\n * Rematch-related libraries.\n */\nconst validate = (runValidations: () => Validation[]): void => {\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tconst validations = runValidations()\n\t\tconst errors: string[] = []\n\n\t\tvalidations.forEach((validation) => {\n\t\t\tconst isInvalid = validation[0]\n\t\t\tconst errorMessage = validation[1]\n\t\t\tif (isInvalid) {\n\t\t\t\terrors.push(errorMessage)\n\t\t\t}\n\t\t})\n\n\t\tif (errors.length > 0) {\n\t\t\tthrow new Error(errors.join(', '))\n\t\t}\n\t}\n}\n\nexport const validateConfig = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\tconfig: Config<TModels, TExtraModels>\n): void => {\n\tvalidate(() => [\n\t\t[!Array.isArray(config.plugins), 'init config.plugins must be an array'],\n\t\t[!isObject(config.models), 'init config.models must be an object'],\n\t\t[\n\t\t\t!isObject(config.redux.reducers),\n\t\t\t'init config.redux.reducers must be an object',\n\t\t],\n\t\t[\n\t\t\t!Array.isArray(config.redux.middlewares),\n\t\t\t'init config.redux.middlewares must be an array',\n\t\t],\n\t\t[\n\t\t\t!Array.isArray(config.redux.enhancers),\n\t\t\t'init config.redux.enhancers must be an array of functions',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(config.redux.combineReducers),\n\t\t\t'init config.redux.combineReducers must be a function',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(config.redux.createStore),\n\t\t\t'init config.redux.createStore must be a function',\n\t\t],\n\t])\n}\n\nexport const validateModel = <TModels extends Models<TModels>>(\n\tmodel: NamedModel<TModels>\n): void => {\n\tvalidate(() => [\n\t\t[!model, 'model config is required'],\n\t\t[typeof model.name !== 'string', 'model \"name\" [string] is required'],\n\t\t[\n\t\t\tmodel.state === undefined && model.baseReducer === undefined,\n\t\t\t'model \"state\" is required',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(model.baseReducer),\n\t\t\t'model \"baseReducer\" must be a function',\n\t\t],\n\t])\n}\n\nexport const validatePlugin = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\tplugin: Plugin<TModels, TExtraModels>\n): void => {\n\tvalidate(() => [\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.onStoreCreated),\n\t\t\t'Plugin onStoreCreated must be a function',\n\t\t],\n\t\t[!ifDefinedIsFunction(plugin.onModel), 'Plugin onModel must be a function'],\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.onReducer),\n\t\t\t'Plugin onReducer must be a function',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.onRootReducer),\n\t\t\t'Plugin onRootReducer must be a function',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.createMiddleware),\n\t\t\t'Plugin createMiddleware must be a function',\n\t\t],\n\t])\n}\n\nexport const validateModelReducer = (\n\tmodelName: string,\n\treducers: ModelReducers,\n\treducerName: string\n): void => {\n\tvalidate(() => [\n\t\t[\n\t\t\t!!reducerName.match(/\\/.+\\//),\n\t\t\t`Invalid reducer name (${modelName}/${reducerName})`,\n\t\t],\n\t\t[\n\t\t\ttypeof reducers[reducerName] !== 'function',\n\t\t\t`Invalid reducer (${modelName}/${reducerName}). Must be a function`,\n\t\t],\n\t])\n}\n\nexport const validateModelEffect = <TModels extends Models<TModels>>(\n\tmodelName: string,\n\teffects: ModelEffects<TModels>,\n\teffectName: string\n): void => {\n\tvalidate(() => [\n\t\t[\n\t\t\t!!effectName.match(/\\//),\n\t\t\t`Invalid effect name (${modelName}/${effectName})`,\n\t\t],\n\t\t[\n\t\t\ttypeof effects[effectName] !== 'function',\n\t\t\t`Invalid effect (${modelName}/${effectName}). Must be a function`,\n\t\t],\n\t])\n}\n\nexport default validate\n","import {\n\tAction,\n\tModelEffects,\n\tModelEffectsCreator,\n\tModels,\n\tNamedModel,\n\tRematchBag,\n\tRematchDispatcher,\n\tRematchStore,\n} from './types'\nimport { validateModelEffect, validateModelReducer } from './validate'\n\n/**\n * Builds a dispatcher for given model name and action name. The dispatched\n * action will have a type `modelName/actionName`.\n * Additionally, adds the isEffect property to the created dispatcher.\n * isEffect helps to differentiate effects dispatchers from reducer dispatchers.\n */\nconst createActionDispatcher = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\trematch: RematchStore<TModels, TExtraModels>,\n\tmodelName: string,\n\tactionName: string,\n\tisEffect: boolean\n): RematchDispatcher<boolean> => {\n\treturn Object.assign(\n\t\t(payload?: any, meta?: any): Action => {\n\t\t\tconst action: Action = { type: `${modelName}/${actionName}` }\n\n\t\t\tif (typeof payload !== 'undefined') {\n\t\t\t\taction.payload = payload\n\t\t\t}\n\n\t\t\tif (typeof meta !== 'undefined') {\n\t\t\t\taction.meta = meta\n\t\t\t}\n\n\t\t\treturn rematch.dispatch(action)\n\t\t},\n\t\t{\n\t\t\tisEffect,\n\t\t}\n\t)\n}\n\n/**\n * Creates a dispatcher object for a model - it contains a mapping from all\n * reducers to functions which dispatch their corresponding actions.\n */\nexport const createReducerDispatcher = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTModel extends NamedModel<TModels>\n>(\n\trematch: RematchStore<TModels, TExtraModels>,\n\tmodel: TModel\n): void => {\n\tconst modelDispatcher = rematch.dispatch[model.name]\n\n\t// map reducer names to dispatch actions\n\tconst modelReducersKeys = Object.keys(model.reducers)\n\tmodelReducersKeys.forEach((reducerName) => {\n\t\tvalidateModelReducer(model.name, model.reducers, reducerName)\n\n\t\tmodelDispatcher[reducerName] = createActionDispatcher(\n\t\t\trematch,\n\t\t\tmodel.name,\n\t\t\treducerName,\n\t\t\tfalse\n\t\t)\n\t})\n}\n\n/**\n * Creates effects dispatcher for a model - it contains a mapping from all\n * effects *names* to functions which dispatch their corresponding actions.\n */\nexport const createEffectDispatcher = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTModel extends NamedModel<TModels>\n>(\n\trematch: RematchStore<TModels, TExtraModels>,\n\tbag: RematchBag<TModels, TExtraModels>,\n\tmodel: TModel\n): void => {\n\tconst modelDispatcher = rematch.dispatch[model.name]\n\tlet effects: ModelEffects<TModels> = {}\n\n\t// 'effects' might be actually a function creating effects\n\tif (model.effects) {\n\t\teffects =\n\t\t\ttypeof model.effects === 'function'\n\t\t\t\t? (model.effects as ModelEffectsCreator<TModels>)(rematch.dispatch)\n\t\t\t\t: model.effects\n\t}\n\n\t// map effects names to dispatch actions\n\tconst effectKeys = Object.keys(effects)\n\teffectKeys.forEach((effectName) => {\n\t\tvalidateModelEffect(model.name, effects, effectName)\n\n\t\tbag.effects[`${model.name}/${effectName}`] =\n\t\t\teffects[effectName].bind(modelDispatcher)\n\n\t\tmodelDispatcher[effectName] = createActionDispatcher(\n\t\t\trematch,\n\t\t\tmodel.name,\n\t\t\teffectName,\n\t\t\ttrue\n\t\t)\n\t})\n}\n","import { Config, Model, Models, NamedModel, RematchBag } from './types'\nimport { validateModel } from './validate'\n\n/**\n * Creates and returns a 'Rematch Bag', which is a set of configuration options\n * used by the Rematch library in various functions.\n */\nexport default function createRematchBag<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(config: Config<TModels, TExtraModels>): RematchBag<TModels, TExtraModels> {\n\treturn {\n\t\tmodels: createNamedModels(config.models),\n\t\treduxConfig: config.redux,\n\t\tforEachPlugin(method, fn): void {\n\t\t\tconfig.plugins.forEach((plugin) => {\n\t\t\t\tif (plugin[method]) {\n\t\t\t\t\tfn(plugin[method]!)\n\t\t\t\t}\n\t\t\t})\n\t\t},\n\t\teffects: {},\n\t}\n}\n\n/**\n * Transforms mapping from a model name to a model object, into an array of\n * 'named' models - models with embedded name and default value for reducers\n * if user didn't provide any.\n */\nfunction createNamedModels<TModels extends Models<TModels>>(\n\tmodels: TModels | Partial<TModels>\n): NamedModel<TModels>[] {\n\treturn Object.keys(models).map((modelName: string) => {\n\t\tconst model = createNamedModel(modelName, (models as TModels)[modelName])\n\t\tvalidateModel(model)\n\t\treturn model\n\t})\n}\n\n/**\n * Transforms a model into 'named' model - model which contains 'name' and\n * 'reducers' properties if user didn't provide any.\n */\nfunction createNamedModel<TModels extends Models<TModels>>(\n\tname: string,\n\tmodel: Model<TModels>\n): NamedModel<TModels> {\n\treturn {\n\t\tname,\n\t\treducers: {},\n\t\t...model,\n\t}\n}\n","import { Middleware } from 'redux'\nimport {\n\tAction,\n\tConfig,\n\tExposedFunction,\n\tModels,\n\tNamedModel,\n\tObjectNotAFunction,\n\tPlugin,\n\tRematchBag,\n\tRematchStore,\n\tModelDispatcher,\n\tRematchDispatch,\n} from './types'\nimport createReduxStore, {\n\tcreateModelReducer,\n\tcreateRootReducer,\n} from './reduxStore'\nimport { createReducerDispatcher, createEffectDispatcher } from './dispatcher'\nimport { validateModel } from './validate'\nimport createRematchBag from './bag'\n\nexport default function createRematchStore<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(config: Config<TModels, TExtraModels>): RematchStore<TModels, TExtraModels> {\n\t// setup rematch 'bag' for storing useful values and functions\n\tconst bag = createRematchBag(config)\n\n\t// add middleware for handling effects\n\tbag.reduxConfig.middlewares.push(createEffectsMiddleware(bag))\n\n\t// collect middlewares from plugins\n\tbag.forEachPlugin('createMiddleware', (createMiddleware) => {\n\t\tbag.reduxConfig.middlewares.push(createMiddleware(bag))\n\t})\n\n\tconst reduxStore = createReduxStore(bag)\n\n\tlet rematchStore = {\n\t\t...reduxStore,\n\t\tname: config.name,\n\t\taddModel(model: NamedModel<TModels>) {\n\t\t\tvalidateModel(model)\n\t\t\tcreateModelReducer(bag, model)\n\t\t\tprepareModel(rematchStore, model)\n\t\t\tenhanceModel(rematchStore, bag, model)\n\t\t\treduxStore.replaceReducer(createRootReducer(bag))\n\t\t\treduxStore.dispatch({ type: '@@redux/REPLACE' })\n\t\t},\n\t} as RematchStore<TModels, TExtraModels>\n\n\taddExposed(rematchStore, config.plugins)\n\n\t/**\n\t * generate dispatch[modelName][actionName] for all reducers and effects\n\t *\n\t * Note: To have circular models accessible in effects method with destructing,\n\t *       ensure that model generation and effects generation execute in\n\t *       different steps.\n\t */\n\tbag.models.forEach((model) => prepareModel(rematchStore, model))\n\tbag.models.forEach((model) => enhanceModel(rematchStore, bag, model))\n\n\tbag.forEachPlugin('onStoreCreated', (onStoreCreated) => {\n\t\trematchStore = onStoreCreated(rematchStore, bag) || rematchStore\n\t})\n\n\treturn rematchStore\n}\n\nfunction createEffectsMiddleware<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(bag: RematchBag<TModels, TExtraModels>): Middleware {\n\treturn (store) =>\n\t\t(next) =>\n\t\t(action: Action): any => {\n\t\t\tif (action.type in bag.effects) {\n\t\t\t\t// first run reducer action if exists\n\t\t\t\tnext(action)\n\n\t\t\t\t// then run the effect and return its result\n\t\t\t\treturn (bag.effects as any)[action.type](\n\t\t\t\t\taction.payload,\n\t\t\t\t\tstore.getState(),\n\t\t\t\t\taction.meta\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn next(action)\n\t\t}\n}\n\nfunction prepareModel<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTModel extends NamedModel<TModels>\n>(rematchStore: RematchStore<TModels, TExtraModels>, model: TModel): void {\n\tconst modelDispatcher = {} as ModelDispatcher<TModel, TModels>\n\n\t// inject model so effects creator can access it\n\trematchStore.dispatch[`${model.name}` as keyof RematchDispatch<TModels>] =\n\t\tmodelDispatcher\n\n\tcreateReducerDispatcher(rematchStore, model)\n}\n\nfunction enhanceModel<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTModel extends NamedModel<TModels>\n>(\n\trematchStore: RematchStore<TModels, TExtraModels>,\n\tbag: RematchBag<TModels, TExtraModels>,\n\tmodel: TModel\n): void {\n\tcreateEffectDispatcher(rematchStore, bag, model)\n\n\tbag.forEachPlugin('onModel', (onModel) => {\n\t\tonModel(model, rematchStore)\n\t})\n}\n\n/**\n * Adds properties exposed by plugins into the Rematch instance. If a exposed\n * property is a function, it passes rematch as the first argument.\n *\n * If you're implementing a plugin in TypeScript, extend Rematch namespace by\n * adding the properties that you exposed from your plugin.\n */\nfunction addExposed<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\tstore: RematchStore<TModels, TExtraModels>,\n\tplugins: Plugin<TModels, TExtraModels>[]\n): void {\n\tplugins.forEach((plugin) => {\n\t\tif (!plugin.exposed) return\n\t\tconst pluginKeys = Object.keys(plugin.exposed)\n\t\tpluginKeys.forEach((key) => {\n\t\t\tif (!plugin.exposed) return\n\t\t\tconst exposedItem = plugin.exposed[key] as\n\t\t\t\t| ExposedFunction<TModels, TExtraModels>\n\t\t\t\t| ObjectNotAFunction\n\t\t\tconst isExposedFunction = typeof exposedItem === 'function'\n\n\t\t\tstore[key] = isExposedFunction\n\t\t\t\t? (...params: any[]): any =>\n\t\t\t\t\t\t(exposedItem as ExposedFunction<TModels, TExtraModels>)(\n\t\t\t\t\t\t\tstore,\n\t\t\t\t\t\t\t...params\n\t\t\t\t\t\t)\n\t\t\t\t: Object.create(plugin.exposed[key])\n\t\t})\n\t})\n}\n","import { InitConfig, Config, Models } from './types'\nimport { validateConfig, validatePlugin } from './validate'\n\nlet count = 0\n\n/**\n * Builds complete Rematch config using default values for properties not\n * supplied by the user. Additionally, applies changes to the config made by\n * the plugins selected by the user.\n */\nexport default function createConfig<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\tinitConfig: InitConfig<TModels, TExtraModels>\n): Config<TModels, TExtraModels> {\n\tconst storeName = initConfig.name ?? `Rematch Store ${count}`\n\n\tcount += 1\n\n\tconst config = {\n\t\tname: storeName,\n\t\tmodels: initConfig.models || {},\n\t\tplugins: initConfig.plugins || [],\n\t\tredux: {\n\t\t\treducers: {},\n\t\t\trootReducers: {},\n\t\t\tenhancers: [],\n\t\t\tmiddlewares: [],\n\t\t\t...initConfig.redux,\n\t\t\tdevtoolOptions: {\n\t\t\t\tname: storeName,\n\t\t\t\t...(initConfig.redux?.devtoolOptions ?? {}),\n\t\t\t},\n\t\t},\n\t} as Config<TModels, TExtraModels>\n\n\tvalidateConfig(config)\n\n\t// Apply changes to the config required by plugins\n\tconfig.plugins.forEach((plugin) => {\n\t\tif (plugin.config) {\n\t\t\t// Collect new models\n\t\t\tconfig.models = merge(config.models, plugin.config.models)\n\n\t\t\t// Collect redux configuration changes\n\t\t\tif (plugin.config.redux) {\n\t\t\t\tconfig.redux.initialState = merge(\n\t\t\t\t\tconfig.redux.initialState,\n\t\t\t\t\tplugin.config.redux.initialState\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.reducers = merge(\n\t\t\t\t\tconfig.redux.reducers,\n\t\t\t\t\tplugin.config.redux.reducers\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.rootReducers = merge(\n\t\t\t\t\tconfig.redux.rootReducers,\n\t\t\t\t\tplugin.config.redux.reducers\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.enhancers = [\n\t\t\t\t\t...config.redux.enhancers,\n\t\t\t\t\t...(plugin.config.redux.enhancers || []),\n\t\t\t\t]\n\n\t\t\t\tconfig.redux.middlewares = [\n\t\t\t\t\t...config.redux.middlewares,\n\t\t\t\t\t...(plugin.config.redux.middlewares || []),\n\t\t\t\t]\n\n\t\t\t\tconfig.redux.combineReducers =\n\t\t\t\t\tconfig.redux.combineReducers || plugin.config.redux.combineReducers\n\n\t\t\t\tconfig.redux.createStore =\n\t\t\t\t\tconfig.redux.createStore || plugin.config.redux.createStore\n\t\t\t}\n\t\t}\n\n\t\tvalidatePlugin(plugin)\n\t})\n\n\treturn config as Config<TModels, TExtraModels>\n}\n\n/**\n * Shallow merges original object with the extra object, giving the precedence\n * to the original object.\n */\nfunction merge<\n\tT extends Record<string, unknown>,\n\tU extends Record<string, unknown> = T\n>(original: T, extra?: U): T | (T & U) {\n\treturn extra ? { ...extra, ...original } : original\n}\n","import createRematchStore from './rematchStore'\nimport { InitConfig, Models, RematchStore, ModelCreator } from './types'\nimport createConfig from './config'\n\n/**\n * Prepares a complete configuration and creates a Rematch store.\n */\nexport const init = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels> = Record<string, never>\n>(\n\tinitConfig?: InitConfig<TModels, TExtraModels>\n): RematchStore<TModels, TExtraModels> => {\n\tconst config = createConfig(initConfig || {})\n\treturn createRematchStore(config)\n}\n\nexport const createModel: ModelCreator = () => (mo) => mo as any\n\nexport default {\n\tinit,\n\tcreateModel,\n}\n\nexport * from './types'\n","////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Actions represent the type of change to a location value.\n */\nexport enum Action {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Pop = \"POP\",\n\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Push = \"PUSH\",\n\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Replace = \"REPLACE\",\n}\n\n/**\n * The pathname, search, and hash values of a URL.\n */\nexport interface Path {\n  /**\n   * A URL pathname, beginning with a /.\n   */\n  pathname: string;\n\n  /**\n   * A URL search string, beginning with a ?.\n   */\n  search: string;\n\n  /**\n   * A URL fragment identifier, beginning with a #.\n   */\n  hash: string;\n}\n\n/**\n * An entry in a history stack. A location contains information about the\n * URL path, as well as possibly some arbitrary state and a key.\n */\nexport interface Location extends Path {\n  /**\n   * A value of arbitrary data associated with this location.\n   */\n  state: any;\n\n  /**\n   * A unique string associated with this location. May be used to safely store\n   * and retrieve data in some other storage API, like `localStorage`.\n   *\n   * Note: This value is always \"default\" on the initial location.\n   */\n  key: string;\n}\n\n/**\n * A change to the current location.\n */\nexport interface Update {\n  /**\n   * The action that triggered the change.\n   */\n  action: Action;\n\n  /**\n   * The new location.\n   */\n  location: Location;\n}\n\n/**\n * A function that receives notifications about location changes.\n */\nexport interface Listener {\n  (update: Update): void;\n}\n\n/**\n * Describes a location that is the destination of some navigation, either via\n * `history.push` or `history.replace`. May be either a URL or the pieces of a\n * URL path.\n */\nexport type To = string | Partial<Path>;\n\n/**\n * A history is an interface to the navigation stack. The history serves as the\n * source of truth for the current location, as well as provides a set of\n * methods that may be used to change it.\n *\n * It is similar to the DOM's `window.history` object, but with a smaller, more\n * focused API.\n */\nexport interface History {\n  /**\n   * The last action that modified the current location. This will always be\n   * Action.Pop when a history instance is first created. This value is mutable.\n   */\n  readonly action: Action;\n\n  /**\n   * The current location. This value is mutable.\n   */\n  readonly location: Location;\n\n  /**\n   * Returns a valid href for the given `to` value that may be used as\n   * the value of an <a href> attribute.\n   *\n   * @param to - The destination URL\n   */\n  createHref(to: To): string;\n\n  /**\n   * Encode a location the same way window.history would do (no-op for memory\n   * history) so we ensure our PUSH/REPLAC e navigations for data routers\n   * behave the same as POP\n   *\n   * @param location The incoming location from router.navigate()\n   */\n  encodeLocation(location: Location): Location;\n\n  /**\n   * Pushes a new location onto the history stack, increasing its length by one.\n   * If there were any entries in the stack after the current one, they are\n   * lost.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  push(to: To, state?: any): void;\n\n  /**\n   * Replaces the current location in the history stack with a new one.  The\n   * location that was replaced will no longer be available.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  replace(to: To, state?: any): void;\n\n  /**\n   * Navigates `n` entries backward/forward in the history stack relative to the\n   * current index. For example, a \"back\" navigation would use go(-1).\n   *\n   * @param delta - The delta in the stack index\n   */\n  go(delta: number): void;\n\n  /**\n   * Sets up a listener that will be called whenever the current location\n   * changes.\n   *\n   * @param listener - A function that will be called when the location changes\n   * @returns unlisten - A function that may be used to stop listening\n   */\n  listen(listener: Listener): () => void;\n}\n\ntype HistoryState = {\n  usr: any;\n  key?: string;\n};\n\nconst PopStateEventType = \"popstate\";\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Memory History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A user-supplied object that describes a location. Used when providing\n * entries to `createMemoryHistory` via its `initialEntries` option.\n */\nexport type InitialEntry = string | Partial<Location>;\n\nexport type MemoryHistoryOptions = {\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n  v5Compat?: boolean;\n};\n\n/**\n * A memory history stores locations in memory. This is useful in stateful\n * environments where there is no web browser, such as node tests or React\n * Native.\n */\nexport interface MemoryHistory extends History {\n  /**\n   * The current index in the history stack.\n   */\n  readonly index: number;\n}\n\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nexport function createMemoryHistory(\n  options: MemoryHistoryOptions = {}\n): MemoryHistory {\n  let { initialEntries = [\"/\"], initialIndex, v5Compat = false } = options;\n  let entries: Location[]; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) =>\n    createMemoryLocation(\n      entry,\n      typeof entry === \"string\" ? null : entry.state,\n      index === 0 ? \"default\" : undefined\n    )\n  );\n  let index = clampIndex(\n    initialIndex == null ? entries.length - 1 : initialIndex\n  );\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  function clampIndex(n: number): number {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation(): Location {\n    return entries[index];\n  }\n  function createMemoryLocation(\n    to: To,\n    state: any = null,\n    key?: string\n  ): Location {\n    let location = createLocation(\n      entries ? getCurrentLocation().pathname : \"/\",\n      to,\n      state,\n      key\n    );\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in memory history: ${JSON.stringify(\n        to\n      )}`\n    );\n    return location;\n  }\n\n  let history: MemoryHistory = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref(to) {\n      return typeof to === \"string\" ? to : createPath(to);\n    },\n    encodeLocation(location) {\n      return location;\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      index = clampIndex(index + delta);\n      if (listener) {\n        listener({ action, location: getCurrentLocation() });\n      }\n    },\n    listen(fn: Listener) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    },\n  };\n\n  return history;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Browser History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A browser history stores the current location in regular URLs in a web\n * browser environment. This is the standard for most web apps and provides the\n * cleanest URLs the browser's address bar.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory\n */\nexport interface BrowserHistory extends UrlHistory {}\n\nexport type BrowserHistoryOptions = UrlHistoryOptions;\n\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nexport function createBrowserHistory(\n  options: BrowserHistoryOptions = {}\n): BrowserHistory {\n  function createBrowserLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let { pathname, search, hash } = window.location;\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createBrowserHref(window: Window, to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  return getUrlBasedHistory(\n    createBrowserLocation,\n    createBrowserHref,\n    null,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hash History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hash history stores the current location in the fragment identifier portion\n * of the URL in a web browser environment.\n *\n * This is ideal for apps that do not control the server for some reason\n * (because the fragment identifier is never sent to the server), including some\n * shared hosting environments that do not provide fine-grained controls over\n * which pages are served at which URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory\n */\nexport interface HashHistory extends UrlHistory {}\n\nexport type HashHistoryOptions = UrlHistoryOptions;\n\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nexport function createHashHistory(\n  options: HashHistoryOptions = {}\n): HashHistory {\n  function createHashLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\",\n    } = parsePath(window.location.hash.substr(1));\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createHashHref(window: Window, to: To) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n\n  function validateHashLocation(location: Location, to: To) {\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n  }\n\n  return getUrlBasedHistory(\n    createHashLocation,\n    createHashHref,\n    validateHashLocation,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction warning(cond: any, message: string) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location: Location): HistoryState {\n  return {\n    usr: location.state,\n    key: location.key,\n  };\n}\n\n/**\n * Creates a Location object with a unique key from the given Path\n */\nexport function createLocation(\n  current: string | Location,\n  to: To,\n  state: any = null,\n  key?: string\n): Readonly<Location> {\n  let location: Readonly<Location> = {\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\",\n    ...(typeof to === \"string\" ? parsePath(to) : to),\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: (to && (to as Location).key) || key || createKey(),\n  };\n  return location;\n}\n\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nexport function createPath({\n  pathname = \"/\",\n  search = \"\",\n  hash = \"\",\n}: Partial<Path>) {\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nexport function parsePath(path: string): Partial<Path> {\n  let parsedPath: Partial<Path> = {};\n\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport function createURL(location: Location | string): URL {\n  // window.location.origin is \"null\" (the literal string value) in Firefox\n  // under certain conditions, notably when serving from a local HTML file\n  // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n  let base =\n    typeof window !== \"undefined\" &&\n    typeof window.location !== \"undefined\" &&\n    window.location.origin !== \"null\"\n      ? window.location.origin\n      : \"unknown://unknown\";\n  let href = typeof location === \"string\" ? location : createPath(location);\n  return new URL(href, base);\n}\n\nexport interface UrlHistory extends History {}\n\nexport type UrlHistoryOptions = {\n  window?: Window;\n  v5Compat?: boolean;\n};\n\nfunction getUrlBasedHistory(\n  getLocation: (window: Window, globalHistory: Window[\"history\"]) => Location,\n  createHref: (window: Window, to: To) => string,\n  validateLocation: ((location: Location, to: To) => void) | null,\n  options: UrlHistoryOptions = {}\n): UrlHistory {\n  let { window = document.defaultView!, v5Compat = false } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  function handlePop() {\n    action = Action.Pop;\n    if (listener) {\n      listener({ action, location: history.location });\n    }\n  }\n\n  function push(to: To, state?: any) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    let historyState = getHistoryState(location);\n    let url = history.createHref(location);\n\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location });\n    }\n  }\n\n  function replace(to: To, state?: any) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    let historyState = getHistoryState(location);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location });\n    }\n  }\n\n  let history: History = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn: Listener) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    encodeLocation(location) {\n      // Encode a Location the same way window.location would\n      let url = createURL(createPath(location));\n      return {\n        ...location,\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash,\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    },\n  };\n\n  return history;\n}\n\n//#endregion\n","import type { Location, Path, To } from \"./history\";\nimport { parsePath } from \"./history\";\n\n/**\n * Map of routeId -> data returned from a loader/action/error\n */\nexport interface RouteData {\n  [routeId: string]: any;\n}\n\nexport enum ResultType {\n  data = \"data\",\n  deferred = \"deferred\",\n  redirect = \"redirect\",\n  error = \"error\",\n}\n\n/**\n * Successful result from a loader or action\n */\nexport interface SuccessResult {\n  type: ResultType.data;\n  data: any;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Successful defer() result from a loader or action\n */\nexport interface DeferredResult {\n  type: ResultType.deferred;\n  deferredData: DeferredData;\n}\n\n/**\n * Redirect result from a loader or action\n */\nexport interface RedirectResult {\n  type: ResultType.redirect;\n  status: number;\n  location: string;\n  revalidate: boolean;\n}\n\n/**\n * Unsuccessful result from a loader or action\n */\nexport interface ErrorResult {\n  type: ResultType.error;\n  error: any;\n  headers?: Headers;\n}\n\n/**\n * Result from a loader or action - potentially successful or unsuccessful\n */\nexport type DataResult =\n  | SuccessResult\n  | DeferredResult\n  | RedirectResult\n  | ErrorResult;\n\nexport type FormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\nexport type FormEncType =\n  | \"application/x-www-form-urlencoded\"\n  | \"multipart/form-data\";\n\n/**\n * @private\n * Internal interface to pass around for action submissions, not intended for\n * external consumption\n */\nexport interface Submission {\n  formMethod: Exclude<FormMethod, \"get\">;\n  formAction: string;\n  formEncType: FormEncType;\n  formData: FormData;\n}\n\n/**\n * @private\n * Arguments passed to route loader/action functions.  Same for now but we keep\n * this as a private implementation detail in case they diverge in the future.\n */\ninterface DataFunctionArgs {\n  request: Request;\n  params: Params;\n}\n\n/**\n * Arguments passed to loader functions\n */\nexport interface LoaderFunctionArgs extends DataFunctionArgs {}\n\n/**\n * Arguments passed to action functions\n */\nexport interface ActionFunctionArgs extends DataFunctionArgs {}\n\n/**\n * Route loader function signature\n */\nexport interface LoaderFunction {\n  (args: LoaderFunctionArgs): Promise<Response> | Response | Promise<any> | any;\n}\n\n/**\n * Route action function signature\n */\nexport interface ActionFunction {\n  (args: ActionFunctionArgs): Promise<Response> | Response | Promise<any> | any;\n}\n\n/**\n * Route shouldRevalidate function signature.  This runs after any submission\n * (navigation or fetcher), so we flatten the navigation/fetcher submission\n * onto the arguments.  It shouldn't matter whether it came from a navigation\n * or a fetcher, what really matters is the URLs and the formData since loaders\n * have to re-run based on the data models that were potentially mutated.\n */\nexport interface ShouldRevalidateFunction {\n  (args: {\n    currentUrl: URL;\n    currentParams: AgnosticDataRouteMatch[\"params\"];\n    nextUrl: URL;\n    nextParams: AgnosticDataRouteMatch[\"params\"];\n    formMethod?: Submission[\"formMethod\"];\n    formAction?: Submission[\"formAction\"];\n    formEncType?: Submission[\"formEncType\"];\n    formData?: Submission[\"formData\"];\n    actionResult?: DataResult;\n    defaultShouldRevalidate: boolean;\n  }): boolean;\n}\n\n/**\n * Base RouteObject with common props shared by all types of routes\n */\ntype AgnosticBaseRouteObject = {\n  caseSensitive?: boolean;\n  path?: string;\n  id?: string;\n  loader?: LoaderFunction;\n  action?: ActionFunction;\n  hasErrorBoundary?: boolean;\n  shouldRevalidate?: ShouldRevalidateFunction;\n  handle?: any;\n};\n\n/**\n * Index routes must not have children\n */\nexport type AgnosticIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: undefined;\n  index: true;\n};\n\n/**\n * Non-index routes may have children, but cannot have index\n */\nexport type AgnosticNonIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: AgnosticRouteObject[];\n  index?: false;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport type AgnosticRouteObject =\n  | AgnosticIndexRouteObject\n  | AgnosticNonIndexRouteObject;\n\nexport type AgnosticDataIndexRouteObject = AgnosticIndexRouteObject & {\n  id: string;\n};\n\nexport type AgnosticDataNonIndexRouteObject = AgnosticNonIndexRouteObject & {\n  children?: AgnosticDataRouteObject[];\n  id: string;\n};\n\n/**\n * A data route object, which is just a RouteObject with a required unique ID\n */\nexport type AgnosticDataRouteObject =\n  | AgnosticDataIndexRouteObject\n  | AgnosticDataNonIndexRouteObject;\n\n// Recursive helper for finding path parameters in the absence of wildcards\ntype _PathParam<Path extends string> =\n  // split path into individual path segments\n  Path extends `${infer L}/${infer R}`\n    ? _PathParam<L> | _PathParam<R>\n    : // find params after `:`\n    Path extends `${string}:${infer Param}`\n    ? Param\n    : // otherwise, there aren't any params present\n      never;\n\n/**\n * Examples:\n * \"/a/b/*\" -> \"*\"\n * \":a\" -> \"a\"\n * \"/a/:b\" -> \"b\"\n * \"/a/blahblahblah:b\" -> \"b\"\n * \"/:a/:b\" -> \"a\" | \"b\"\n * \"/:a/b/:c/*\" -> \"a\" | \"c\" | \"*\"\n */\ntype PathParam<Path extends string> =\n  // check if path is just a wildcard\n  Path extends \"*\"\n    ? \"*\"\n    : // look for wildcard at the end of the path\n    Path extends `${infer Rest}/*`\n    ? \"*\" | _PathParam<Rest>\n    : // look for params in the absence of wildcards\n      _PathParam<Path>;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  // if could not find path params, fallback to `string`\n  [PathParam<Segment>] extends [never] ? string : PathParam<Segment>;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface AgnosticRouteMatch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObjectType;\n}\n\nexport interface AgnosticDataRouteMatch\n  extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {}\n\nfunction isIndexRoute(\n  route: AgnosticRouteObject\n): route is AgnosticIndexRouteObject {\n  return route.index === true;\n}\n\n// Walk the route tree generating unique IDs where necessary so we are working\n// solely with AgnosticDataRouteObject's within the Router\nexport function convertRoutesToDataRoutes(\n  routes: AgnosticRouteObject[],\n  parentPath: number[] = [],\n  allIds: Set<string> = new Set<string>()\n): AgnosticDataRouteObject[] {\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(\n      route.index !== true || !route.children,\n      `Cannot specify children on an index route`\n    );\n    invariant(\n      !allIds.has(id),\n      `Found a route id collision on id \"${id}\".  Route ` +\n        \"id's must be globally unique within Data Router usages\"\n    );\n    allIds.add(id);\n\n    if (isIndexRoute(route)) {\n      let indexRoute: AgnosticDataIndexRouteObject = { ...route, id };\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute: AgnosticDataNonIndexRouteObject = {\n        ...route,\n        id,\n        children: route.children\n          ? convertRoutesToDataRoutes(route.children, treePath, allIds)\n          : undefined,\n      };\n      return pathOrLayoutRoute;\n    }\n  });\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-routes\n */\nexport function matchRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): AgnosticRouteMatch<string, RouteObjectType>[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch<string, RouteObjectType>(\n      branches[i],\n      // Incoming pathnames are generally encoded from either window.location\n      // or from router.navigate, but we want to match against the unencoded\n      // paths in the route definitions.  Memory router locations won't be\n      // encoded here but there also shouldn't be anything to decode so this\n      // should be a safe operation.  This avoids needing matchRoutes to be\n      // history-aware.\n      safelyDecodeURI(pathname)\n    );\n  }\n\n  return matches;\n}\n\ninterface RouteMeta<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObjectType;\n}\n\ninterface RouteBranch<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta<RouteObjectType>[];\n}\n\nfunction flattenRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  branches: RouteBranch<RouteObjectType>[] = [],\n  parentsMeta: RouteMeta<RouteObjectType>[] = [],\n  parentPath = \"\"\n): RouteBranch<RouteObjectType>[] {\n  routes.forEach((route, index) => {\n    let meta: RouteMeta<RouteObjectType> = {\n      relativePath: route.path || \"\",\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({ path, score: computeScore(path, route.index), routesMeta });\n  });\n\n  return branches;\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  branch: RouteBranch<RouteObjectType>,\n  pathname: string\n): AgnosticRouteMatch<ParamKey, RouteObjectType>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: AgnosticRouteMatch<ParamKey, RouteObjectType>[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams as Params<ParamKey>,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/generate-path\n */\nexport function generatePath<Path extends string>(\n  path: Path,\n  params: {\n    [key in PathParam<Path>]: string;\n  } = {} as any\n): string {\n  return path\n    .replace(/:(\\w+)/g, (_, key: PathParam<Path>) => {\n      invariant(params[key] != null, `Missing \":${key}\" param`);\n      return params[key]!;\n    })\n    .replace(/(\\/?)\\*/, (_, prefix, __, str) => {\n      const star = \"*\" as PathParam<Path>;\n\n      if (params[star] == null) {\n        // If no splat was provided, trim the trailing slash _unless_ it's\n        // the entire path\n        return str === \"/*\" ? \"/\" : \"\";\n      }\n\n      // Apply the splat\n      return `${prefix}${params[star]}`;\n    });\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else {\n    // Nothing to match for \"\" or \"/\"\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURI(value: string) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(\n      false,\n      `The URL path \"${value}\" could not be decoded because it is is a ` +\n        `malformed URL segment. This is probably due to a bad percent ` +\n        `encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * @private\n */\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\")\n    ? basename.length - 1\n    : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(startIndex) || \"/\";\n}\n\n/**\n * @private\n */\nexport function invariant(value: boolean, message?: string): asserts value;\nexport function invariant<T>(\n  value: T | null | undefined,\n  message?: string\n): asserts value is T;\nexport function invariant(value: any, message?: string) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\n/**\n * @private\n */\nexport function warning(cond: any, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/resolve-path\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction getInvalidPathError(\n  char: string,\n  field: string,\n  dest: string,\n  path: Partial<Path>\n) {\n  return (\n    `Cannot include a '${char}' character in a manually specified ` +\n    `\\`to.${field}\\` field [${JSON.stringify(\n      path\n    )}].  Please separate it out to the ` +\n    `\\`to.${dest}\\` field. Alternatively you may provide the full path as ` +\n    `a string in <Link to=\"...\"> and the router will parse it for you.`\n  );\n}\n\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nexport function getPathContributingMatches<\n  T extends AgnosticRouteMatch = AgnosticRouteMatch\n>(matches: T[]) {\n  return matches.filter(\n    (match, index) =>\n      index === 0 || (match.route.path && match.route.path.length > 0)\n  );\n}\n\n/**\n * @private\n */\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string,\n  isPathRelative = false\n): Path {\n  let to: Partial<Path>;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = { ...toArg };\n\n    invariant(\n      !to.pathname || !to.pathname.includes(\"?\"),\n      getInvalidPathError(\"?\", \"pathname\", \"search\", to)\n    );\n    invariant(\n      !to.pathname || !to.pathname.includes(\"#\"),\n      getInvalidPathError(\"#\", \"pathname\", \"hash\", to)\n    );\n    invariant(\n      !to.search || !to.search.includes(\"#\"),\n      getInvalidPathError(\"#\", \"search\", \"hash\", to)\n    );\n  }\n\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n\n  let from: string;\n\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (isPathRelative || toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash =\n    toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash =\n    (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (\n    !path.pathname.endsWith(\"/\") &&\n    (hasExplicitTrailingSlash || hasCurrentTrailingSlash)\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\n/**\n * @private\n */\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\n/**\n * @private\n */\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\n/**\n * @private\n */\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\n/**\n * @private\n */\nexport const normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\n/**\n * @private\n */\nexport const normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\nexport type JsonFunction = <Data>(\n  data: Data,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nexport const json: JsonFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n\n  return new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers,\n  });\n};\n\nexport interface TrackedPromise extends Promise<any> {\n  _tracked?: boolean;\n  _data?: any;\n  _error?: any;\n}\n\nexport class AbortedDeferredError extends Error {}\n\nexport class DeferredData {\n  private pendingKeys: Set<string | number> = new Set<string | number>();\n  private controller: AbortController;\n  private abortPromise: Promise<void>;\n  private unlistenAbortSignal: () => void;\n  private subscriber?: (aborted: boolean) => void = undefined;\n  data: Record<string, unknown>;\n\n  constructor(data: Record<string, unknown>) {\n    invariant(\n      data && typeof data === \"object\" && !Array.isArray(data),\n      \"defer() only accepts plain objects\"\n    );\n\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject: (e: AbortedDeferredError) => void;\n    this.abortPromise = new Promise((_, r) => (reject = r));\n    this.controller = new AbortController();\n    let onAbort = () =>\n      reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () =>\n      this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n\n    this.data = Object.entries(data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: this.trackPromise(key, value),\n        }),\n      {}\n    );\n  }\n\n  private trackPromise(\n    key: string | number,\n    value: Promise<unknown> | unknown\n  ): TrackedPromise | unknown {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n\n    this.pendingKeys.add(key);\n\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise: TrackedPromise = Promise.race([value, this.abortPromise]).then(\n      (data) => this.onSettle(promise, key, null, data as unknown),\n      (error) => this.onSettle(promise, key, error as unknown)\n    );\n\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n\n    Object.defineProperty(promise, \"_tracked\", { get: () => true });\n    return promise;\n  }\n\n  private onSettle(\n    promise: TrackedPromise,\n    key: string | number,\n    error: unknown,\n    data?: unknown\n  ): unknown {\n    if (\n      this.controller.signal.aborted &&\n      error instanceof AbortedDeferredError\n    ) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      return Promise.reject(error);\n    }\n\n    this.pendingKeys.delete(key);\n\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n\n    const subscriber = this.subscriber;\n    if (error) {\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      subscriber && subscriber(false);\n      return Promise.reject(error);\n    }\n\n    Object.defineProperty(promise, \"_data\", { get: () => data });\n    subscriber && subscriber(false);\n    return data;\n  }\n\n  subscribe(fn: (aborted: boolean) => void) {\n    this.subscriber = fn;\n  }\n\n  cancel() {\n    this.controller.abort();\n    this.pendingKeys.forEach((v, k) => this.pendingKeys.delete(k));\n    let subscriber = this.subscriber;\n    subscriber && subscriber(true);\n  }\n\n  async resolveData(signal: AbortSignal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise((resolve) => {\n        this.subscribe((aborted) => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n\n  get done() {\n    return this.pendingKeys.size === 0;\n  }\n\n  get unwrappedData() {\n    invariant(\n      this.data !== null && this.done,\n      \"Can only unwrap data on initialized and settled deferreds\"\n    );\n\n    return Object.entries(this.data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: unwrapTrackedPromise(value),\n        }),\n      {}\n    );\n  }\n}\n\nfunction isTrackedPromise(value: any): value is TrackedPromise {\n  return (\n    value instanceof Promise && (value as TrackedPromise)._tracked === true\n  );\n}\n\nfunction unwrapTrackedPromise(value: any) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\n\nexport function defer(data: Record<string, unknown>) {\n  return new DeferredData(data);\n}\n\nexport type RedirectFunction = (\n  url: string,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirect: RedirectFunction = (url, init = 302) => {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n\n  return new Response(null, {\n    ...responseInit,\n    headers,\n  });\n};\n\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */\nexport class ErrorResponse {\n  status: number;\n  statusText: string;\n  data: any;\n\n  constructor(status: number, statusText: string | undefined, data: any) {\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.data = data;\n  }\n}\n\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response throw from an action/loader\n */\nexport function isRouteErrorResponse(e: any): e is ErrorResponse {\n  return e instanceof ErrorResponse;\n}\n","import type { History, Location, To } from \"./history\";\nimport {\n  Action as HistoryAction,\n  createLocation,\n  createPath,\n  createURL,\n  parsePath,\n} from \"./history\";\nimport type {\n  DataResult,\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteObject,\n  DeferredResult,\n  ErrorResult,\n  FormEncType,\n  FormMethod,\n  RedirectResult,\n  RouteData,\n  AgnosticRouteObject,\n  Submission,\n  SuccessResult,\n  AgnosticRouteMatch,\n} from \"./utils\";\nimport {\n  DeferredData,\n  ErrorResponse,\n  ResultType,\n  convertRoutesToDataRoutes,\n  getPathContributingMatches,\n  invariant,\n  isRouteErrorResponse,\n  joinPaths,\n  matchRoutes,\n  resolveTo,\n} from \"./utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Router instance manages all navigation and data loading/mutations\n */\nexport interface Router {\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the basename for the router\n   */\n  get basename(): RouterInit[\"basename\"];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the current state of the router\n   */\n  get state(): RouterState;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the routes for this router instance\n   */\n  get routes(): AgnosticDataRouteObject[];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Initialize the router, including adding history listeners and kicking off\n   * initial data fetches.  Returns a function to cleanup listeners and abort\n   * any in-progress loads\n   */\n  initialize(): Router;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Subscribe to router.state updates\n   *\n   * @param fn function to call with the new state\n   */\n  subscribe(fn: RouterSubscriber): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Enable scroll restoration behavior in the router\n   *\n   * @param savedScrollPositions Object that will manage positions, in case\n   *                             it's being restored from sessionStorage\n   * @param getScrollPosition    Function to get the active Y scroll position\n   * @param getKey               Function to get the key to use for restoration\n   */\n  enableScrollRestoration(\n    savedScrollPositions: Record<string, number>,\n    getScrollPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Navigate forward/backward in the history stack\n   * @param to Delta to move in the history stack\n   */\n  navigate(to: number): void;\n\n  /**\n   * Navigate to the given path\n   * @param to Path to navigate to\n   * @param opts Navigation options (method, submission, etc.)\n   */\n  navigate(to: To, opts?: RouterNavigateOptions): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a fetcher load/submission\n   *\n   * @param key     Fetcher key\n   * @param routeId Route that owns the fetcher\n   * @param href    href to fetch\n   * @param opts    Fetcher options, (method, submission, etc.)\n   */\n  fetch(\n    key: string,\n    routeId: string,\n    href: string,\n    opts?: RouterNavigateOptions\n  ): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a revalidation of all current route loaders and fetcher loads\n   */\n  revalidate(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to create an href for the given location\n   * @param location\n   */\n  createHref(location: Location | URL): string;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get/create a fetcher for the given key\n   * @param key\n   */\n  getFetcher<TData = any>(key?: string): Fetcher<TData>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete the fetcher for a given key\n   * @param key\n   */\n  deleteFetcher(key?: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Cleanup listeners and abort any in-progress loads\n   */\n  dispose(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal fetch AbortControllers accessed by unit tests\n   */\n  _internalFetchControllers: Map<string, AbortController>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal pending DeferredData instances accessed by unit tests\n   */\n  _internalActiveDeferreds: Map<string, DeferredData>;\n}\n\n/**\n * State maintained internally by the router.  During a navigation, all states\n * reflect the the \"old\" location unless otherwise noted.\n */\nexport interface RouterState {\n  /**\n   * The action of the most recent navigation\n   */\n  historyAction: HistoryAction;\n\n  /**\n   * The current location reflected by the router\n   */\n  location: Location;\n\n  /**\n   * The current set of route matches\n   */\n  matches: AgnosticDataRouteMatch[];\n\n  /**\n   * Tracks whether we've completed our initial data load\n   */\n  initialized: boolean;\n\n  /**\n   * Current scroll position we should start at for a new view\n   *  - number -> scroll position to restore to\n   *  - false -> do not restore scroll at all (used during submissions)\n   *  - null -> don't have a saved position, scroll to hash or top of page\n   */\n  restoreScrollPosition: number | false | null;\n\n  /**\n   * Indicate whether this navigation should skip resetting the scroll position\n   * if we are unable to restore the scroll position\n   */\n  preventScrollReset: boolean;\n\n  /**\n   * Tracks the state of the current navigation\n   */\n  navigation: Navigation;\n\n  /**\n   * Tracks any in-progress revalidations\n   */\n  revalidation: RevalidationState;\n\n  /**\n   * Data from the loaders for the current matches\n   */\n  loaderData: RouteData;\n\n  /**\n   * Data from the action for the current matches\n   */\n  actionData: RouteData | null;\n\n  /**\n   * Errors caught from loaders for the current matches\n   */\n  errors: RouteData | null;\n\n  /**\n   * Map of current fetchers\n   */\n  fetchers: Map<string, Fetcher>;\n}\n\n/**\n * Data that can be passed into hydrate a Router from SSR\n */\nexport type HydrationState = Partial<\n  Pick<RouterState, \"loaderData\" | \"actionData\" | \"errors\">\n>;\n\n/**\n * Initialization options for createRouter\n */\nexport interface RouterInit {\n  basename?: string;\n  routes: AgnosticRouteObject[];\n  history: History;\n  hydrationData?: HydrationState;\n}\n\n/**\n * State returned from a server-side query() call\n */\nexport interface StaticHandlerContext {\n  location: RouterState[\"location\"];\n  matches: RouterState[\"matches\"];\n  loaderData: RouterState[\"loaderData\"];\n  actionData: RouterState[\"actionData\"];\n  errors: RouterState[\"errors\"];\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n  actionHeaders: Record<string, Headers>;\n  _deepestRenderedBoundaryId?: string | null;\n}\n\n/**\n * A StaticHandler instance manages a singular SSR navigation/fetch event\n */\nexport interface StaticHandler {\n  dataRoutes: AgnosticDataRouteObject[];\n  query(request: Request): Promise<StaticHandlerContext | Response>;\n  queryRoute(request: Request, routeId?: string): Promise<any>;\n}\n\n/**\n * Subscriber function signature for changes to router state\n */\nexport interface RouterSubscriber {\n  (state: RouterState): void;\n}\n\ninterface UseMatchesMatch {\n  id: string;\n  pathname: string;\n  params: AgnosticRouteMatch[\"params\"];\n  data: unknown;\n  handle: unknown;\n}\n\n/**\n * Function signature for determining the key to be used in scroll restoration\n * for a given location\n */\nexport interface GetScrollRestorationKeyFunction {\n  (location: Location, matches: UseMatchesMatch[]): string | null;\n}\n\n/**\n * Function signature for determining the current scroll position\n */\nexport interface GetScrollPositionFunction {\n  (): number;\n}\n\n/**\n * Options for a navigate() call for a Link navigation\n */\ntype LinkNavigateOptions = {\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n};\n\n/**\n * Options for a navigate() call for a Form navigation\n */\ntype SubmissionNavigateOptions = {\n  replace?: boolean;\n  state?: any;\n  formMethod?: FormMethod;\n  formEncType?: FormEncType;\n  formData: FormData;\n};\n\n/**\n * Options to pass to navigate() for either a Link or Form navigation\n */\nexport type RouterNavigateOptions =\n  | LinkNavigateOptions\n  | SubmissionNavigateOptions;\n\n/**\n * Options to pass to fetch()\n */\nexport type RouterFetchOptions =\n  | Omit<LinkNavigateOptions, \"replace\">\n  | Omit<SubmissionNavigateOptions, \"replace\">;\n\n/**\n * Potential states for state.navigation\n */\nexport type NavigationStates = {\n  Idle: {\n    state: \"idle\";\n    location: undefined;\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    formData: undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    location: Location;\n    formMethod: FormMethod | undefined;\n    formAction: string | undefined;\n    formEncType: FormEncType | undefined;\n    formData: FormData | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    location: Location;\n    formMethod: FormMethod;\n    formAction: string;\n    formEncType: FormEncType;\n    formData: FormData;\n  };\n};\n\nexport type Navigation = NavigationStates[keyof NavigationStates];\n\nexport type RevalidationState = \"idle\" | \"loading\";\n\n/**\n * Potential states for fetchers\n */\ntype FetcherStates<TData = any> = {\n  Idle: {\n    state: \"idle\";\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    formData: undefined;\n    data: TData | undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    formMethod: FormMethod | undefined;\n    formAction: string | undefined;\n    formEncType: FormEncType | undefined;\n    formData: FormData | undefined;\n    data: TData | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    formMethod: FormMethod;\n    formAction: string;\n    formEncType: FormEncType;\n    formData: FormData;\n    data: TData | undefined;\n  };\n};\n\nexport type Fetcher<TData = any> =\n  FetcherStates<TData>[keyof FetcherStates<TData>];\n\ninterface ShortCircuitable {\n  /**\n   * startNavigation does not need to complete the navigation because we\n   * redirected or got interrupted\n   */\n  shortCircuited?: boolean;\n}\n\ninterface HandleActionResult extends ShortCircuitable {\n  /**\n   * Error thrown from the current action, keyed by the route containing the\n   * error boundary to render the error.  To be committed to the state after\n   * loaders have completed\n   */\n  pendingActionError?: RouteData;\n  /**\n   * Data returned from the current action, keyed by the route owning the action.\n   * To be committed to the state after loaders have completed\n   */\n  pendingActionData?: RouteData;\n}\n\ninterface HandleLoadersResult extends ShortCircuitable {\n  /**\n   * loaderData returned from the current set of loaders\n   */\n  loaderData?: RouterState[\"loaderData\"];\n  /**\n   * errors thrown from the current set of loaders\n   */\n  errors?: RouterState[\"errors\"];\n}\n\n/**\n * Tuple of [key, href, DataRouteMatch, DataRouteMatch[]] for a revalidating\n * fetcher.load()\n */\ntype RevalidatingFetcher = [\n  string,\n  string,\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteMatch[]\n];\n\n/**\n * Tuple of [href, DataRouteMatch, DataRouteMatch[]] for an active\n * fetcher.load()\n */\ntype FetchLoadMatch = [\n  string,\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteMatch[]\n];\n\n/**\n * Wrapper object to allow us to throw any response out from callLoaderOrAction\n * for queryRouter while preserving whether or not it was thrown or returned\n * from the loader/action\n */\ninterface QueryRouteResponse {\n  type: ResultType.data | ResultType.error;\n  response: Response;\n}\n\nexport const IDLE_NAVIGATION: NavigationStates[\"Idle\"] = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n};\n\nexport const IDLE_FETCHER: FetcherStates[\"Idle\"] = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n};\n\nconst isBrowser =\n  typeof window !== \"undefined\" &&\n  typeof window.document !== \"undefined\" &&\n  typeof window.document.createElement !== \"undefined\";\nconst isServer = !isBrowser;\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Create a router and listen to history POP navigations\n */\nexport function createRouter(init: RouterInit): Router {\n  invariant(\n    init.routes.length > 0,\n    \"You must provide a non-empty routes array to createRouter\"\n  );\n\n  let dataRoutes = convertRoutesToDataRoutes(init.routes);\n  // Cleanup function for history\n  let unlistenHistory: (() => void) | null = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set<RouterSubscriber>();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions: Record<string, number> | null = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey: GetScrollRestorationKeyFunction | null = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition: GetScrollPositionFunction | null = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  let initialScrollRestored = false;\n\n  let initialMatches = matchRoutes(\n    dataRoutes,\n    init.history.location,\n    init.basename\n  );\n  let initialErrors: RouteData | null = null;\n\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let { matches, route, error } = getNotFoundMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = { [route.id]: error };\n  }\n\n  let initialized =\n    !initialMatches.some((m) => m.route.loader) || init.hydrationData != null;\n\n  let router: Router;\n  let state: RouterState = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    restoreScrollPosition: null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: (init.hydrationData && init.hydrationData.loaderData) || {},\n    actionData: (init.hydrationData && init.hydrationData.actionData) || null,\n    errors: (init.hydrationData && init.hydrationData.errors) || initialErrors,\n    fetchers: new Map(),\n  };\n\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction: HistoryAction = HistoryAction.Pop;\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n  // AbortController for the active navigation\n  let pendingNavigationController: AbortController | null;\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidate()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes: string[] = [];\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads: string[] = [];\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map<string, AbortController>();\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map<string, number>();\n  // Fetchers that triggered redirect navigations from their actions\n  let fetchRedirectIds = new Set<string>();\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map<string, FetchLoadMatch>();\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map<string, DeferredData>();\n\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(\n      ({ action: historyAction, location }) =>\n        startNavigation(historyAction, location)\n    );\n\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    if (!state.initialized) {\n      startNavigation(HistoryAction.Pop, state.location);\n    }\n\n    return router;\n  }\n\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n  }\n\n  // Subscribe to state updates for the router\n  function subscribe(fn: RouterSubscriber) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n\n  // Update our state and notify the calling context of the change\n  function updateState(newState: Partial<RouterState>): void {\n    state = {\n      ...state,\n      ...newState,\n    };\n    subscribers.forEach((subscriber) => subscriber(state));\n  }\n\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(\n    location: Location,\n    newState: Partial<Omit<RouterState, \"action\" | \"location\" | \"navigation\">>\n  ): void {\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a submission\n    // - We're past the submitting state and into the loading state\n    // - The location we've finished loading is different from the submission\n    //   location, indicating we redirected from the action (avoids false\n    //   positives for loading/submissionRedirect when actionData returned\n    //   on a prior submission)\n    let isActionReload =\n      state.actionData != null &&\n      state.navigation.formMethod != null &&\n      state.navigation.state === \"loading\" &&\n      state.navigation.formAction?.split(\"?\")[0] === location.pathname;\n\n    // Always preserve any existing loaderData from re-used routes\n    let newLoaderData = newState.loaderData\n      ? {\n          loaderData: mergeLoaderData(\n            state.loaderData,\n            newState.loaderData,\n            newState.matches || []\n          ),\n        }\n      : {};\n\n    updateState({\n      // Clear existing actionData on any completed navigation beyond the original\n      // action, unless we're currently finishing the loading/actionReload state.\n      // Do this prior to spreading in newState in case we got back to back actions\n      ...(isActionReload ? {} : { actionData: null }),\n      ...newState,\n      ...newLoaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      // Don't restore on submission navigations\n      restoreScrollPosition: state.navigation.formData\n        ? false\n        : getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset: pendingPreventScrollReset,\n    });\n\n    if (isUninterruptedRevalidation) {\n      // If this was an uninterrupted revalidation then do not touch history\n    } else if (pendingAction === HistoryAction.Pop) {\n      // Do nothing for POP - URL has already been updated\n    } else if (pendingAction === HistoryAction.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === HistoryAction.Replace) {\n      init.history.replace(location, location.state);\n    }\n\n    // Reset stateful navigation vars\n    pendingAction = HistoryAction.Pop;\n    pendingPreventScrollReset = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(\n    to: number | To,\n    opts?: RouterNavigateOptions\n  ): Promise<void> {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n\n    let { path, submission, error } = normalizeNavigateOptions(to, opts);\n\n    let location = createLocation(state.location, path, opts && opts.state);\n\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    location = init.history.encodeLocation(location);\n\n    let historyAction =\n      (opts && opts.replace) === true || submission != null\n        ? HistoryAction.Replace\n        : HistoryAction.Push;\n    let preventScrollReset =\n      opts && \"preventScrollReset\" in opts\n        ? opts.preventScrollReset === true\n        : undefined;\n\n    return await startNavigation(historyAction, location, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n    });\n  }\n\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({ revalidation: \"loading\" });\n\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true,\n      });\n      return;\n    }\n\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(\n      pendingAction || state.historyAction,\n      state.navigation.location,\n      { overrideNavigation: state.navigation }\n    );\n  }\n\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(\n    historyAction: HistoryAction,\n    location: Location,\n    opts?: {\n      submission?: Submission;\n      overrideNavigation?: Navigation;\n      pendingError?: ErrorResponse;\n      startUninterruptedRevalidation?: boolean;\n      preventScrollReset?: boolean;\n      replace?: boolean;\n    }\n  ): Promise<void> {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation =\n      (opts && opts.startUninterruptedRevalidation) === true;\n\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(dataRoutes, location, init.basename);\n\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let {\n        matches: notFoundMatches,\n        route,\n        error,\n      } = getNotFoundMatches(dataRoutes);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error,\n        },\n      });\n      return;\n    }\n\n    // Short circuit if it's only a hash change\n    if (isHashChangeOnly(state.location, location)) {\n      completeNavigation(location, { matches });\n      return;\n    }\n\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createRequest(\n      location,\n      pendingNavigationController.signal,\n      opts && opts.submission\n    );\n    let pendingActionData: RouteData | undefined;\n    let pendingError: RouteData | undefined;\n\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError,\n      };\n    } else if (opts && opts.submission) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(\n        request,\n        location,\n        opts.submission,\n        matches,\n        { replace: opts.replace }\n      );\n\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n\n      let navigation: NavigationStates[\"Loading\"] = {\n        state: \"loading\",\n        location,\n        ...opts.submission,\n      };\n      loadingNavigation = navigation;\n    }\n\n    // Call loaders\n    let { shortCircuited, loaderData, errors } = await handleLoaders(\n      request,\n      location,\n      matches,\n      loadingNavigation,\n      opts && opts.submission,\n      opts && opts.replace,\n      pendingActionData,\n      pendingError\n    );\n\n    if (shortCircuited) {\n      return;\n    }\n\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n\n    completeNavigation(location, {\n      matches,\n      loaderData,\n      errors,\n    });\n  }\n\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(\n    request: Request,\n    location: Location,\n    submission: Submission,\n    matches: AgnosticDataRouteMatch[],\n    opts?: { replace?: boolean }\n  ): Promise<HandleActionResult> {\n    interruptActiveLoads();\n\n    // Put us in a submitting state\n    let navigation: NavigationStates[\"Submitting\"] = {\n      state: \"submitting\",\n      location,\n      ...submission,\n    };\n    updateState({ navigation });\n\n    // Call our action and get the result\n    let result: DataResult;\n    let actionMatch = getTargetMatch(matches, location);\n\n    if (!actionMatch.route.action) {\n      result = getMethodNotAllowedResult(location);\n    } else {\n      result = await callLoaderOrAction(\n        \"action\",\n        request,\n        actionMatch,\n        matches,\n        router.basename\n      );\n\n      if (request.signal.aborted) {\n        return { shortCircuited: true };\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      let redirectNavigation: NavigationStates[\"Loading\"] = {\n        state: \"loading\",\n        location: createLocation(state.location, result.location),\n        ...submission,\n      };\n      await startRedirectNavigation(\n        result,\n        redirectNavigation,\n        opts && opts.replace\n      );\n      return { shortCircuited: true };\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = HistoryAction.Push;\n      }\n\n      return {\n        pendingActionError: { [boundaryMatch.route.id]: result.error },\n      };\n    }\n\n    if (isDeferredResult(result)) {\n      throw new Error(\"defer() is not supported in actions\");\n    }\n\n    return {\n      pendingActionData: { [actionMatch.route.id]: result.data },\n    };\n  }\n\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    overrideNavigation?: Navigation,\n    submission?: Submission,\n    replace?: boolean,\n    pendingActionData?: RouteData,\n    pendingError?: RouteData\n  ): Promise<HandleLoadersResult> {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation = overrideNavigation;\n    if (!loadingNavigation) {\n      let navigation: NavigationStates[\"Loading\"] = {\n        state: \"loading\",\n        location,\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n      };\n      loadingNavigation = navigation;\n    }\n\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      state,\n      matches,\n      submission,\n      location,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      pendingActionData,\n      pendingError,\n      fetchLoadMatches\n    );\n\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(\n      (routeId) =>\n        !(matches && matches.some((m) => m.route.id === routeId)) ||\n        (matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId))\n    );\n\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      completeNavigation(location, {\n        matches,\n        loaderData: mergeLoaderData(state.loaderData, {}, matches),\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null,\n        actionData: pendingActionData || null,\n      });\n      return { shortCircuited: true };\n    }\n\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    if (!isUninterruptedRevalidation) {\n      revalidatingFetchers.forEach(([key]) => {\n        let fetcher = state.fetchers.get(key);\n        let revalidatingFetcher: FetcherStates[\"Loading\"] = {\n          state: \"loading\",\n          data: fetcher && fetcher.data,\n          formMethod: undefined,\n          formAction: undefined,\n          formEncType: undefined,\n          formData: undefined,\n        };\n        state.fetchers.set(key, revalidatingFetcher);\n      });\n      updateState({\n        navigation: loadingNavigation,\n        actionData: pendingActionData || state.actionData || null,\n        ...(revalidatingFetchers.length > 0\n          ? { fetchers: new Map(state.fetchers) }\n          : {}),\n      });\n    }\n\n    pendingNavigationLoadId = ++incrementingLoadId;\n    revalidatingFetchers.forEach(([key]) =>\n      fetchControllers.set(key, pendingNavigationController!)\n    );\n\n    let { results, loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        request\n      );\n\n    if (request.signal.aborted) {\n      return { shortCircuited: true };\n    }\n\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    revalidatingFetchers.forEach(([key]) => fetchControllers.delete(key));\n\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      let redirectNavigation = getLoaderRedirect(state, redirect);\n      await startRedirectNavigation(redirect, redirectNavigation, replace);\n      return { shortCircuited: true };\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      matchesToLoad,\n      loaderResults,\n      pendingError,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe((aborted) => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n\n    markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n\n    return {\n      loaderData,\n      errors,\n      ...(didAbortFetchLoads || revalidatingFetchers.length > 0\n        ? { fetchers: new Map(state.fetchers) }\n        : {}),\n    };\n  }\n\n  function getFetcher<TData = any>(key: string): Fetcher<TData> {\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(\n    key: string,\n    routeId: string,\n    href: string,\n    opts?: RouterFetchOptions\n  ) {\n    if (isServer) {\n      throw new Error(\n        \"router.fetch() was called during the server render, but it shouldn't be. \" +\n          \"You are likely calling a useFetcher() method in the body of your component. \" +\n          \"Try moving it to a useEffect or a callback.\"\n      );\n    }\n\n    if (fetchControllers.has(key)) abortFetcher(key);\n\n    let matches = matchRoutes(dataRoutes, href, init.basename);\n    if (!matches) {\n      setFetcherError(key, routeId, new ErrorResponse(404, \"Not Found\", null));\n      return;\n    }\n\n    let { path, submission } = normalizeNavigateOptions(href, opts, true);\n    let match = getTargetMatch(matches, path);\n\n    if (submission) {\n      handleFetcherAction(key, routeId, path, match, matches, submission);\n      return;\n    }\n\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, [path, match, matches]);\n    handleFetcherLoader(key, routeId, path, match, matches);\n  }\n\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    requestMatches: AgnosticDataRouteMatch[],\n    submission: Submission\n  ) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n\n    if (!match.route.action) {\n      let { error } = getMethodNotAllowedResult(path);\n      setFetcherError(key, routeId, error);\n      return;\n    }\n\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    let fetcher: FetcherStates[\"Submitting\"] = {\n      state: \"submitting\",\n      ...submission,\n      data: existingFetcher && existingFetcher.data,\n    };\n    state.fetchers.set(key, fetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createRequest(path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n\n    let actionResult = await callLoaderOrAction(\n      \"action\",\n      fetchRequest,\n      match,\n      requestMatches,\n      router.basename\n    );\n\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by ou our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      fetchRedirectIds.add(key);\n      let loadingFetcher: FetcherStates[\"Loading\"] = {\n        state: \"loading\",\n        ...submission,\n        data: undefined,\n      };\n      state.fetchers.set(key, loadingFetcher);\n      updateState({ fetchers: new Map(state.fetchers) });\n\n      let redirectNavigation: NavigationStates[\"Loading\"] = {\n        state: \"loading\",\n        location: createLocation(state.location, actionResult.location),\n        ...submission,\n      };\n      await startRedirectNavigation(actionResult, redirectNavigation);\n      return;\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n\n    if (isDeferredResult(actionResult)) {\n      invariant(false, \"defer() is not supported in actions\");\n    }\n\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createRequest(\n      nextLocation,\n      abortController.signal\n    );\n    let matches =\n      state.navigation.state !== \"idle\"\n        ? matchRoutes(dataRoutes, state.navigation.location, init.basename)\n        : state.matches;\n\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n\n    let loadFetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      data: actionResult.data,\n      ...submission,\n    };\n    state.fetchers.set(key, loadFetcher);\n\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      state,\n      matches,\n      submission,\n      nextLocation,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      { [match.route.id]: actionResult.data },\n      undefined, // No need to send through errors since we short circuit above\n      fetchLoadMatches\n    );\n\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers\n      .filter(([staleKey]) => staleKey !== key)\n      .forEach(([staleKey]) => {\n        let existingFetcher = state.fetchers.get(staleKey);\n        let revalidatingFetcher: FetcherStates[\"Loading\"] = {\n          state: \"loading\",\n          data: existingFetcher && existingFetcher.data,\n          formMethod: undefined,\n          formAction: undefined,\n          formEncType: undefined,\n          formData: undefined,\n        };\n        state.fetchers.set(staleKey, revalidatingFetcher);\n        fetchControllers.set(staleKey, abortController);\n      });\n\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    let { results, loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        revalidationRequest\n      );\n\n    if (abortController.signal.aborted) {\n      return;\n    }\n\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach(([staleKey]) =>\n      fetchControllers.delete(staleKey)\n    );\n\n    let redirect = findRedirect(results);\n    if (redirect) {\n      let redirectNavigation = getLoaderRedirect(state, redirect);\n      await startRedirectNavigation(redirect, redirectNavigation);\n      return;\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      state.matches,\n      matchesToLoad,\n      loaderResults,\n      undefined,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    let doneFetcher: FetcherStates[\"Idle\"] = {\n      state: \"idle\",\n      data: actionResult.data,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n    };\n    state.fetchers.set(key, doneFetcher);\n\n    let didAbortFetchLoads = abortStaleFetchLoads(loadId);\n\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (\n      state.navigation.state === \"loading\" &&\n      loadId > pendingNavigationLoadId\n    ) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers),\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches),\n        ...(didAbortFetchLoads ? { fetchers: new Map(state.fetchers) } : {}),\n      });\n      isRevalidationRequired = false;\n    }\n  }\n\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    matches: AgnosticDataRouteMatch[]\n  ) {\n    let existingFetcher = state.fetchers.get(key);\n    // Put this fetcher into it's loading state\n    let loadingFetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      data: existingFetcher && existingFetcher.data,\n    };\n    state.fetchers.set(key, loadingFetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createRequest(path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let result: DataResult = await callLoaderOrAction(\n      \"loader\",\n      fetchRequest,\n      match,\n      matches,\n      router.basename\n    );\n\n    // Deferred isn't supported or fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result =\n        (await resolveDeferredData(result, fetchRequest.signal, true)) ||\n        result;\n    }\n\n    // We can delete this so long as we weren't aborted by ou our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      let redirectNavigation = getLoaderRedirect(state, result);\n      await startRedirectNavigation(result, redirectNavigation);\n      return;\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, routeId);\n      state.fetchers.delete(key);\n      // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n      // do we need to behave any differently with our non-redirect errors?\n      // What if it was a non-redirect Response?\n      updateState({\n        fetchers: new Map(state.fetchers),\n        errors: {\n          [boundaryMatch.route.id]: result.error,\n        },\n      });\n      return;\n    }\n\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n\n    // Put the fetcher back into an idle state\n    let doneFetcher: FetcherStates[\"Idle\"] = {\n      state: \"idle\",\n      data: result.data,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n    };\n    state.fetchers.set(key, doneFetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n  }\n\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(\n    redirect: RedirectResult,\n    navigation: Navigation,\n    replace?: boolean\n  ) {\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n    invariant(\n      navigation.location,\n      \"Expected a location on the redirect navigation\"\n    );\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n\n    let redirectHistoryAction =\n      replace === true ? HistoryAction.Replace : HistoryAction.Push;\n\n    await startNavigation(redirectHistoryAction, navigation.location, {\n      overrideNavigation: navigation,\n    });\n  }\n\n  async function callLoadersAndMaybeResolveData(\n    currentMatches: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[],\n    matchesToLoad: AgnosticDataRouteMatch[],\n    fetchersToLoad: RevalidatingFetcher[],\n    request: Request\n  ) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([\n      ...matchesToLoad.map((match) =>\n        callLoaderOrAction(\"loader\", request, match, matches, router.basename)\n      ),\n      ...fetchersToLoad.map(([, href, match, fetchMatches]) =>\n        callLoaderOrAction(\n          \"loader\",\n          createRequest(href, request.signal),\n          match,\n          fetchMatches,\n          router.basename\n        )\n      ),\n    ]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n\n    await Promise.all([\n      resolveDeferredResults(\n        currentMatches,\n        matchesToLoad,\n        loaderResults,\n        request.signal,\n        false,\n        state.loaderData\n      ),\n      resolveDeferredResults(\n        currentMatches,\n        fetchersToLoad.map(([, , match]) => match),\n        fetcherResults,\n        request.signal,\n        true\n      ),\n    ]);\n\n    return { results, loaderResults, fetcherResults };\n  }\n\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n\n  function setFetcherError(key: string, routeId: string, error: any) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error,\n      },\n      fetchers: new Map(state.fetchers),\n    });\n  }\n\n  function deleteFetcher(key: string): void {\n    if (fetchControllers.has(key)) abortFetcher(key);\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    state.fetchers.delete(key);\n  }\n\n  function abortFetcher(key: string) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, `Expected fetch controller: ${key}`);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n\n  function markFetchersDone(keys: string[]) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher: FetcherStates[\"Idle\"] = {\n        state: \"idle\",\n        data: fetcher.data,\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n      };\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  function markFetchRedirectsDone(): void {\n    let doneKeys = [];\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n      }\n    }\n    markFetchersDone(doneKeys);\n  }\n\n  function abortStaleFetchLoads(landedId: number): boolean {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n\n  function cancelActiveDeferreds(\n    predicate?: (routeId: string) => boolean\n  ): string[] {\n    let cancelledRouteIds: string[] = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(\n    positions: Record<string, number>,\n    getPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || ((location) => location.key);\n\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({ restoreScrollPosition: y });\n      }\n    }\n\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n\n  function saveScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): void {\n    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {\n      let userMatches = matches.map((m) =>\n        createUseMatchesMatch(m, state.loaderData)\n      );\n      let key = getScrollRestorationKey(location, userMatches) || location.key;\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n\n  function getSavedScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): number | null {\n    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {\n      let userMatches = matches.map((m) =>\n        createUseMatchesMatch(m, state.loaderData)\n      );\n      let key = getScrollRestorationKey(location, userMatches) || location.key;\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n\n  router = {\n    get basename() {\n      return init.basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to: To) => init.history.createHref(to),\n    getFetcher,\n    deleteFetcher,\n    dispose,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n  };\n\n  return router;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\n\nconst validActionMethods = new Set([\"POST\", \"PUT\", \"PATCH\", \"DELETE\"]);\nconst validRequestMethods = new Set([\"GET\", \"HEAD\", ...validActionMethods]);\n\nexport function unstable_createStaticHandler(\n  routes: AgnosticRouteObject[]\n): StaticHandler {\n  invariant(\n    routes.length > 0,\n    \"You must provide a non-empty routes array to unstable_createStaticHandler\"\n  );\n\n  let dataRoutes = convertRoutesToDataRoutes(routes);\n\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(\n    request: Request\n  ): Promise<StaticHandlerContext | Response> {\n    let url = new URL(request.url);\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location);\n\n    if (!validRequestMethods.has(request.method)) {\n      let {\n        matches: methodNotAllowedMatches,\n        route,\n        error,\n      } = getMethodNotAllowedMatches(dataRoutes);\n      return {\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n      };\n    } else if (!matches) {\n      let {\n        matches: notFoundMatches,\n        route,\n        error,\n      } = getNotFoundMatches(dataRoutes);\n      return {\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n      };\n    }\n\n    let result = await queryImpl(request, location, matches);\n    if (result instanceof Response) {\n      return result;\n    }\n\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return { location, ...result };\n  }\n\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated thrown Response (such as a\n   * 404 or 405) will have a custom X-Remix-Router-Error: \"yes\" header on it\n   * in order to differentiate from responses thrown from user actions/loaders.\n   */\n  async function queryRoute(request: Request, routeId?: string): Promise<any> {\n    let url = new URL(request.url);\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location);\n\n    if (!validRequestMethods.has(request.method)) {\n      throw createRouterErrorResponse(null, {\n        status: 405,\n        statusText: \"Method Not Allowed\",\n      });\n    } else if (!matches) {\n      throw createRouterErrorResponse(null, {\n        status: 404,\n        statusText: \"Not Found\",\n      });\n    }\n\n    let match = routeId\n      ? matches.find((m) => m.route.id === routeId)\n      : getTargetMatch(matches, location);\n\n    if (!match) {\n      throw createRouterErrorResponse(null, {\n        status: 404,\n        statusText: \"Not Found\",\n      });\n    }\n\n    let result = await queryImpl(request, location, matches, match);\n    if (result instanceof Response) {\n      return result;\n    }\n\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n\n    // Pick off the right state value to return\n    let routeData = [result.actionData, result.loaderData].find((v) => v);\n    return Object.values(routeData || {})[0];\n  }\n\n  async function queryImpl(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    routeMatch?: AgnosticDataRouteMatch\n  ): Promise<Omit<StaticHandlerContext, \"location\"> | Response> {\n    invariant(\n      request.signal,\n      \"query()/queryRoute() requests must contain an AbortController signal\"\n    );\n\n    try {\n      if (validActionMethods.has(request.method)) {\n        let result = await submit(\n          request,\n          matches,\n          routeMatch || getTargetMatch(matches, location),\n          routeMatch != null\n        );\n        return result;\n      }\n\n      let result = await loadRouteData(request, matches, routeMatch);\n      return result instanceof Response\n        ? result\n        : {\n            ...result,\n            actionData: null,\n            actionHeaders: {},\n          };\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error && !isRedirectResponse(e.response)) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  async function submit(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    actionMatch: AgnosticDataRouteMatch,\n    isRouteRequest: boolean\n  ): Promise<Omit<StaticHandlerContext, \"location\"> | Response> {\n    let result: DataResult;\n    if (!actionMatch.route.action) {\n      if (isRouteRequest) {\n        throw createRouterErrorResponse(null, {\n          status: 405,\n          statusText: \"Method Not Allowed\",\n        });\n      }\n      result = getMethodNotAllowedResult(request.url);\n    } else {\n      result = await callLoaderOrAction(\n        \"action\",\n        request,\n        actionMatch,\n        matches,\n        undefined, // Basename not currently supported in static handlers\n        true,\n        isRouteRequest\n      );\n\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? \"queryRoute\" : \"query\";\n        throw new Error(`${method}() call aborted`);\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location,\n        },\n      });\n    }\n\n    if (isDeferredResult(result)) {\n      throw new Error(\"defer() is not supported in actions\");\n    }\n\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n        return {\n          matches: [actionMatch],\n          loaderData: {},\n          actionData: null,\n          errors: {\n            [boundaryMatch.route.id]: result.error,\n          },\n          // Note: statusCode + headers are unused here since queryRoute will\n          // return the raw Response or value\n          statusCode: 500,\n          loaderHeaders: {},\n          actionHeaders: {},\n        };\n      }\n\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: { [actionMatch.route.id]: result.data },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n      };\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(request, matches, undefined, {\n        [boundaryMatch.route.id]: result.error,\n      });\n\n      // action status codes take precedence over loader status codes\n      return {\n        ...context,\n        statusCode: isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500,\n        actionData: null,\n        actionHeaders: {\n          ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n        },\n      };\n    }\n\n    let context = await loadRouteData(request, matches);\n\n    return {\n      ...context,\n      // action status codes take precedence over loader status codes\n      ...(result.statusCode ? { statusCode: result.statusCode } : {}),\n      actionData: {\n        [actionMatch.route.id]: result.data,\n      },\n      actionHeaders: {\n        ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n      },\n    };\n  }\n\n  async function loadRouteData(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    routeMatch?: AgnosticDataRouteMatch,\n    pendingActionError?: RouteData\n  ): Promise<\n    | Omit<StaticHandlerContext, \"location\" | \"actionData\" | \"actionHeaders\">\n    | Response\n  > {\n    let isRouteRequest = routeMatch != null;\n    let requestMatches = routeMatch\n      ? [routeMatch]\n      : getLoaderMatchesUntilBoundary(\n          matches,\n          Object.keys(pendingActionError || {})[0]\n        );\n    let matchesToLoad = requestMatches.filter((m) => m.route.loader);\n\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        loaderData: {},\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n      };\n    }\n\n    let results = await Promise.all([\n      ...matchesToLoad.map((match) =>\n        callLoaderOrAction(\n          \"loader\",\n          request,\n          match,\n          matches,\n          undefined, // Basename not currently supported in static handlers\n          true,\n          isRouteRequest\n        )\n      ),\n    ]);\n\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? \"queryRoute\" : \"query\";\n      throw new Error(`${method}() call aborted`);\n    }\n\n    // Can't do anything with these without the Remix side of things, so just\n    // cancel them for now\n    results.forEach((result) => {\n      if (isDeferredResult(result)) {\n        result.deferredData.cancel();\n      }\n    });\n\n    // Process and commit output from loaders\n    let context = processRouteLoaderData(\n      matches,\n      matchesToLoad,\n      results,\n      pendingActionError\n    );\n\n    return {\n      ...context,\n      matches,\n    };\n  }\n\n  function createRouterErrorResponse(\n    body: BodyInit | null | undefined,\n    init: ResponseInit\n  ) {\n    return new Response(body, {\n      ...init,\n      headers: {\n        ...init.headers,\n        \"X-Remix-Router-Error\": \"yes\",\n      },\n    });\n  }\n\n  return {\n    dataRoutes,\n    query,\n    queryRoute,\n  };\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nexport function getStaticContextFromError(\n  routes: AgnosticDataRouteObject[],\n  context: StaticHandlerContext,\n  error: any\n) {\n  let newContext: StaticHandlerContext = {\n    ...context,\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error,\n    },\n  };\n  return newContext;\n}\n\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(\n  to: To,\n  opts?: RouterNavigateOptions,\n  isFetcher = false\n): {\n  path: string;\n  submission?: Submission;\n  error?: ErrorResponse;\n} {\n  let path = typeof to === \"string\" ? to : createPath(to);\n\n  // Return location verbatim on non-submission navigations\n  if (!opts || (!(\"formMethod\" in opts) && !(\"formData\" in opts))) {\n    return { path };\n  }\n\n  // Create a Submission on non-GET navigations\n  if (opts.formMethod != null && opts.formMethod !== \"get\") {\n    return {\n      path,\n      submission: {\n        formMethod: opts.formMethod,\n        formAction: stripHashFromPath(path),\n        formEncType:\n          (opts && opts.formEncType) || \"application/x-www-form-urlencoded\",\n        formData: opts.formData,\n      },\n    };\n  }\n\n  // No formData to flatten for GET submission\n  if (!opts.formData) {\n    return { path };\n  }\n\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  try {\n    let searchParams = convertFormDataToSearchParams(opts.formData);\n    // Since fetcher GET submissions only run a single loader (as opposed to\n    // navigation GET submissions which run all loaders), we need to preserve\n    // any incoming ?index params\n    if (\n      isFetcher &&\n      parsedPath.search &&\n      hasNakedIndexQuery(parsedPath.search)\n    ) {\n      searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = `?${searchParams}`;\n  } catch (e) {\n    return {\n      path,\n      error: new ErrorResponse(\n        400,\n        \"Bad Request\",\n        \"Cannot submit binary form data using GET\"\n      ),\n    };\n  }\n\n  return { path: createPath(parsedPath) };\n}\n\nfunction getLoaderRedirect(\n  state: RouterState,\n  redirect: RedirectResult\n): Navigation {\n  let { formMethod, formAction, formEncType, formData } = state.navigation;\n  let navigation: NavigationStates[\"Loading\"] = {\n    state: \"loading\",\n    location: createLocation(state.location, redirect.location),\n    formMethod: formMethod || undefined,\n    formAction: formAction || undefined,\n    formEncType: formEncType || undefined,\n    formData: formData || undefined,\n  };\n  return navigation;\n}\n\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(\n  matches: AgnosticDataRouteMatch[],\n  boundaryId?: string\n) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\n\nfunction getMatchesToLoad(\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  submission: Submission | undefined,\n  location: Location,\n  isRevalidationRequired: boolean,\n  cancelledDeferredRoutes: string[],\n  cancelledFetcherLoads: string[],\n  pendingActionData?: RouteData,\n  pendingError?: RouteData,\n  fetchLoadMatches?: Map<string, FetchLoadMatch>\n): [AgnosticDataRouteMatch[], RevalidatingFetcher[]] {\n  let actionResult = pendingError\n    ? Object.values(pendingError)[0]\n    : pendingActionData\n    ? Object.values(pendingActionData)[0]\n    : null;\n\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter(\n    (match, index) =>\n      match.route.loader != null &&\n      (isNewLoader(state.loaderData, state.matches[index], match) ||\n        // If this route had a pending deferred cancelled it must be revalidated\n        cancelledDeferredRoutes.some((id) => id === match.route.id) ||\n        shouldRevalidateLoader(\n          state.location,\n          state.matches[index],\n          submission,\n          location,\n          match,\n          isRevalidationRequired,\n          actionResult\n        ))\n  );\n\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers: RevalidatingFetcher[] = [];\n  fetchLoadMatches &&\n    fetchLoadMatches.forEach(([href, match, fetchMatches], key) => {\n      // This fetcher was cancelled from a prior action submission - force reload\n      if (cancelledFetcherLoads.includes(key)) {\n        revalidatingFetchers.push([key, href, match, fetchMatches]);\n      } else if (isRevalidationRequired) {\n        let shouldRevalidate = shouldRevalidateLoader(\n          href,\n          match,\n          submission,\n          href,\n          match,\n          isRevalidationRequired,\n          actionResult\n        );\n        if (shouldRevalidate) {\n          revalidatingFetchers.push([key, href, match, fetchMatches]);\n        }\n      }\n    });\n\n  return [navigationMatches, revalidatingFetchers];\n}\n\nfunction isNewLoader(\n  currentLoaderData: RouteData,\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let isNew =\n    // [a] -> [a, b]\n    !currentMatch ||\n    // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\n\nfunction isNewRouteInstance(\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    (currentPath &&\n      currentPath.endsWith(\"*\") &&\n      currentMatch.params[\"*\"] !== match.params[\"*\"])\n  );\n}\n\nfunction shouldRevalidateLoader(\n  currentLocation: string | Location,\n  currentMatch: AgnosticDataRouteMatch,\n  submission: Submission | undefined,\n  location: string | Location,\n  match: AgnosticDataRouteMatch,\n  isRevalidationRequired: boolean,\n  actionResult: DataResult | undefined\n) {\n  let currentUrl = createURL(currentLocation);\n  let currentParams = currentMatch.params;\n  let nextUrl = createURL(location);\n  let nextParams = match.params;\n\n  // This is the default implementation as to when we revalidate.  If the route\n  // provides it's own implementation, then we give them full control but\n  // provide this value so they can leverage it if needed after they check\n  // their own specific use cases\n  // Note that fetchers always provide the same current/next locations so the\n  // URL-based checks here don't apply to fetcher shouldRevalidate calls\n  let defaultShouldRevalidate =\n    isNewRouteInstance(currentMatch, match) ||\n    // Clicked the same link, resubmitted a GET form\n    currentUrl.toString() === nextUrl.toString() ||\n    // Search params affect all loaders\n    currentUrl.search !== nextUrl.search ||\n    // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate\n    isRevalidationRequired;\n\n  if (match.route.shouldRevalidate) {\n    let routeChoice = match.route.shouldRevalidate({\n      currentUrl,\n      currentParams,\n      nextUrl,\n      nextParams,\n      ...submission,\n      actionResult,\n      defaultShouldRevalidate,\n    });\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n\n  return defaultShouldRevalidate;\n}\n\nasync function callLoaderOrAction(\n  type: \"loader\" | \"action\",\n  request: Request,\n  match: AgnosticDataRouteMatch,\n  matches: AgnosticDataRouteMatch[],\n  basename: string | undefined,\n  isStaticRequest: boolean = false,\n  isRouteRequest: boolean = false\n): Promise<DataResult> {\n  let resultType;\n  let result;\n\n  // Setup a promise we can race against so that abort signals short circuit\n  let reject: () => void;\n  let abortPromise = new Promise((_, r) => (reject = r));\n  let onReject = () => reject();\n  request.signal.addEventListener(\"abort\", onReject);\n\n  try {\n    let handler = match.route[type];\n    invariant<Function>(\n      handler,\n      `Could not find the ${type} to run on the \"${match.route.id}\" route`\n    );\n\n    result = await Promise.race([\n      handler({ request, params: match.params }),\n      abortPromise,\n    ]);\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    request.signal.removeEventListener(\"abort\", onReject);\n  }\n\n  if (result instanceof Response) {\n    let status = result.status;\n\n    // Process redirects\n    if (status >= 300 && status <= 399) {\n      let location = result.headers.get(\"Location\");\n      invariant(\n        location,\n        \"Redirects returned/thrown from loaders/actions must have a Location header\"\n      );\n\n      // Support relative routing in redirects\n      let activeMatches = matches.slice(0, matches.indexOf(match) + 1);\n      let routePathnames = getPathContributingMatches(activeMatches).map(\n        (match) => match.pathnameBase\n      );\n      let requestPath = createURL(request.url).pathname;\n      let resolvedLocation = resolveTo(location, routePathnames, requestPath);\n      invariant(\n        createPath(resolvedLocation),\n        `Unable to resolve redirect location: ${result.headers.get(\"Location\")}`\n      );\n\n      // Prepend the basename to the redirect location if we have one\n      if (basename) {\n        let path = resolvedLocation.pathname;\n        resolvedLocation.pathname =\n          path === \"/\" ? basename : joinPaths([basename, path]);\n      }\n\n      location = createPath(resolvedLocation);\n\n      // Don't process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n      };\n    }\n\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (isRouteRequest) {\n      // eslint-disable-next-line no-throw-literal\n      throw {\n        type: resultType || ResultType.data,\n        response: result,\n      };\n    }\n\n    let data: any;\n    let contentType = result.headers.get(\"Content-Type\");\n    if (contentType && contentType.startsWith(\"application/json\")) {\n      data = await result.json();\n    } else {\n      data = await result.text();\n    }\n\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponse(status, result.statusText, data),\n        headers: result.headers,\n      };\n    }\n\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers,\n    };\n  }\n\n  if (resultType === ResultType.error) {\n    return { type: resultType, error: result };\n  }\n\n  if (result instanceof DeferredData) {\n    return { type: ResultType.deferred, deferredData: result };\n  }\n\n  return { type: ResultType.data, data: result };\n}\n\nfunction createRequest(\n  location: string | Location,\n  signal: AbortSignal,\n  submission?: Submission\n): Request {\n  let url = createURL(stripHashFromPath(location)).toString();\n  let init: RequestInit = { signal };\n\n  if (submission) {\n    let { formMethod, formEncType, formData } = submission;\n    init.method = formMethod.toUpperCase();\n    init.body =\n      formEncType === \"application/x-www-form-urlencoded\"\n        ? convertFormDataToSearchParams(formData)\n        : formData;\n  }\n\n  // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n  return new Request(url, init);\n}\n\nfunction convertFormDataToSearchParams(formData: FormData): URLSearchParams {\n  let searchParams = new URLSearchParams();\n\n  for (let [key, value] of formData.entries()) {\n    invariant(\n      typeof value === \"string\",\n      'File inputs are not supported with encType \"application/x-www-form-urlencoded\", ' +\n        'please use \"multipart/form-data\" instead.'\n    );\n    searchParams.append(key, value);\n  }\n\n  return searchParams;\n}\n\nfunction processRouteLoaderData(\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingError: RouteData | undefined,\n  activeDeferreds?: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors: RouterState[\"errors\"] | null;\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n} {\n  // Fill in loaderData/errors from our loaders\n  let loaderData: RouterState[\"loaderData\"] = {};\n  let errors: RouterState[\"errors\"] | null = null;\n  let statusCode: number | undefined;\n  let foundError = false;\n  let loaderHeaders: Record<string, Headers> = {};\n\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(\n      !isRedirectResult(result),\n      \"Cannot handle redirect results in processLoaderData\"\n    );\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n      errors = Object.assign(errors || {}, {\n        [boundaryMatch.route.id]: error,\n      });\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else if (isDeferredResult(result)) {\n      activeDeferreds && activeDeferreds.set(id, result.deferredData);\n      loaderData[id] = result.deferredData.data;\n      // TODO: Add statusCode/headers once we wire up streaming in Remix\n    } else {\n      loaderData[id] = result.data;\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (\n        result.statusCode != null &&\n        result.statusCode !== 200 &&\n        !foundError\n      ) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here\n  if (pendingError) {\n    errors = pendingError;\n  }\n\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders,\n  };\n}\n\nfunction processLoaderData(\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingError: RouteData | undefined,\n  revalidatingFetchers: RevalidatingFetcher[],\n  fetcherResults: DataResult[],\n  activeDeferreds: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors?: RouterState[\"errors\"];\n} {\n  let { loaderData, errors } = processRouteLoaderData(\n    matches,\n    matchesToLoad,\n    results,\n    pendingError,\n    activeDeferreds\n  );\n\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let [key, , match] = revalidatingFetchers[index];\n    invariant(\n      fetcherResults !== undefined && fetcherResults[index] !== undefined,\n      \"Did not find corresponding fetcher result\"\n    );\n    let result = fetcherResults[index];\n\n    // Process fetcher non-redirect errors\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = {\n          ...errors,\n          [boundaryMatch.route.id]: result.error,\n        };\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      throw new Error(\"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      throw new Error(\"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher: FetcherStates[\"Idle\"] = {\n        state: \"idle\",\n        data: result.data,\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n      };\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  return { loaderData, errors };\n}\n\nfunction mergeLoaderData(\n  loaderData: RouteData,\n  newLoaderData: RouteData,\n  matches: AgnosticDataRouteMatch[]\n): RouteData {\n  let mergedLoaderData = { ...newLoaderData };\n  matches.forEach((match) => {\n    let id = match.route.id;\n    if (newLoaderData[id] === undefined && loaderData[id] !== undefined) {\n      mergedLoaderData[id] = loaderData[id];\n    }\n  });\n  return mergedLoaderData;\n}\n\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(\n  matches: AgnosticDataRouteMatch[],\n  routeId?: string\n): AgnosticDataRouteMatch {\n  let eligibleMatches = routeId\n    ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1)\n    : [...matches];\n  return (\n    eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) ||\n    matches[0]\n  );\n}\n\nfunction getShortCircuitMatches(\n  routes: AgnosticDataRouteObject[],\n  status: number,\n  statusText: string\n): {\n  matches: AgnosticDataRouteMatch[];\n  route: AgnosticDataRouteObject;\n  error: ErrorResponse;\n} {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n    id: `__shim-${status}-route__`,\n  };\n\n  return {\n    matches: [\n      {\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route,\n      },\n    ],\n    route,\n    error: new ErrorResponse(status, statusText, null),\n  };\n}\n\nfunction getNotFoundMatches(routes: AgnosticDataRouteObject[]) {\n  return getShortCircuitMatches(routes, 404, \"Not Found\");\n}\n\nfunction getMethodNotAllowedMatches(routes: AgnosticDataRouteObject[]) {\n  return getShortCircuitMatches(routes, 405, \"Method Not Allowed\");\n}\n\nfunction getMethodNotAllowedResult(path: Location | string): ErrorResult {\n  let href = typeof path === \"string\" ? path : createPath(path);\n  console.warn(\n    \"You're trying to submit to a route that does not have an action.  To \" +\n      \"fix this, please add an `action` function to the route for \" +\n      `[${href}]`\n  );\n  return {\n    type: ResultType.error,\n    error: new ErrorResponse(405, \"Method Not Allowed\", \"\"),\n  };\n}\n\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results: DataResult[]): RedirectResult | undefined {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return result;\n    }\n  }\n}\n\nfunction stripHashFromPath(path: To) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath({ ...parsedPath, hash: \"\" });\n}\n\nfunction isHashChangeOnly(a: Location, b: Location): boolean {\n  return (\n    a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash\n  );\n}\n\nfunction isDeferredResult(result: DataResult): result is DeferredResult {\n  return result.type === ResultType.deferred;\n}\n\nfunction isErrorResult(result: DataResult): result is ErrorResult {\n  return result.type === ResultType.error;\n}\n\nfunction isRedirectResult(result?: DataResult): result is RedirectResult {\n  return (result && result.type) === ResultType.redirect;\n}\n\nfunction isRedirectResponse(result: any): result is Response {\n  if (!(result instanceof Response)) {\n    return false;\n  }\n\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\n\nfunction isQueryRouteResponse(obj: any): obj is QueryRouteResponse {\n  return (\n    obj &&\n    obj.response instanceof Response &&\n    (obj.type === ResultType.data || ResultType.error)\n  );\n}\n\nasync function resolveDeferredResults(\n  currentMatches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  signal: AbortSignal,\n  isFetcher: boolean,\n  currentLoaderData?: RouteData\n) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    let currentMatch = currentMatches.find(\n      (m) => m.route.id === match.route.id\n    );\n    let isRevalidatingLoader =\n      currentMatch != null &&\n      !isNewRouteInstance(currentMatch, match) &&\n      (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      await resolveDeferredData(result, signal, isFetcher).then((result) => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\n\nasync function resolveDeferredData(\n  result: DeferredResult,\n  signal: AbortSignal,\n  unwrap = false\n): Promise<SuccessResult | ErrorResult | undefined> {\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData,\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e,\n      };\n    }\n  }\n\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data,\n  };\n}\n\nfunction hasNakedIndexQuery(search: string): boolean {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\n\n// Note: This should match the format exported by useMatches, so if you change\n// this please also change that :)  Eventually we'll DRY this up\nfunction createUseMatchesMatch(\n  match: AgnosticDataRouteMatch,\n  loaderData: RouteData\n): UseMatchesMatch {\n  let { route, pathname, params } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id] as unknown,\n    handle: route.handle as unknown,\n  };\n}\n\nfunction getTargetMatch(\n  matches: AgnosticDataRouteMatch[],\n  location: Location | string\n) {\n  let search =\n    typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (\n    matches[matches.length - 1].route.index &&\n    hasNakedIndexQuery(search || \"\")\n  ) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\n//#endregion\n","'use strict';\n\nvar reactIs = require('react-is');\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  '$$typeof': true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  '$$typeof': true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {};\nTYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\nTYPE_STATICS[reactIs.Memo] = MEMO_STATICS;\n\nfunction getStatics(component) {\n  // React v16.11 and below\n  if (reactIs.isMemo(component)) {\n    return MEMO_STATICS;\n  } // React v16.12 and above\n\n\n  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n}\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    var targetStatics = getStatics(targetComponent);\n    var sourceStatics = getStatics(sourceComponent);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n","/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';var b=\"function\"===typeof Symbol&&Symbol.for,c=b?Symbol.for(\"react.element\"):60103,d=b?Symbol.for(\"react.portal\"):60106,e=b?Symbol.for(\"react.fragment\"):60107,f=b?Symbol.for(\"react.strict_mode\"):60108,g=b?Symbol.for(\"react.profiler\"):60114,h=b?Symbol.for(\"react.provider\"):60109,k=b?Symbol.for(\"react.context\"):60110,l=b?Symbol.for(\"react.async_mode\"):60111,m=b?Symbol.for(\"react.concurrent_mode\"):60111,n=b?Symbol.for(\"react.forward_ref\"):60112,p=b?Symbol.for(\"react.suspense\"):60113,q=b?\nSymbol.for(\"react.suspense_list\"):60120,r=b?Symbol.for(\"react.memo\"):60115,t=b?Symbol.for(\"react.lazy\"):60116,v=b?Symbol.for(\"react.block\"):60121,w=b?Symbol.for(\"react.fundamental\"):60117,x=b?Symbol.for(\"react.responder\"):60118,y=b?Symbol.for(\"react.scope\"):60119;\nfunction z(a){if(\"object\"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;\nexports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};\nexports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};\nexports.isValidElementType=function(a){return\"string\"===typeof a||\"function\"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||\"object\"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-is.production.min.js');\n} else {\n  module.exports = require('./cjs/react-is.development.js');\n}\n","// \nmodule.exports = {\n  \"\": [[\"m\"], [\"q\"]],\n  \"\": [[\"shng\"], [\"gun\"]],\n  \"\": [[\"dng\"], [\"fng\"]],\n  \"\": [[\"dng\"], [\"gu\"]],\n  \"\": [[\"dng\"], [\"mn\"]],\n  \"\": [[\"yu\"], [\"zhng\"]],\n  \"\": [[\"q\"], [\"gun\"]],\n  \"\": [[\"zhng\"], [\"d\"]],\n  \"\": [[\"lng\"], [\"h\"]],\n  \"\": [[\"zhng\"], [\"sn\"]],\n  \"\": [[\"gng\"], [\"y\"]],\n  \"\": [[\"gng\"], [\"sn\"]],\n  \"\": [[\"gng\"], [\"yng\"]],\n  \"\": [[\"gng\"], [\"ling\"]],\n  \"\": [[\"gng\"], [\"x\"]],\n  \"\": [[\"chn\"], [\"y\"]],\n  \"\": [[\"nn\"], [\"gng\"]],\n  \"\": [[\"nn\"], [\"mn\"]],\n  \"\": [[\"s\"], [\"ku\"]],\n  \"\": [[\"s\"], [\"t\"]],\n  \"\": [[\"s\"], [\"kng\"]],\n  \"\": [[\"s\"], [\"m\"]],\n  \"\": [[\"h\"], [\"yn\"]],\n  \"\": [[\"rng\"], [\"s\"]],\n  \"\": [[\"xi\"], [\"hu\"]],\n  \"\": [[\"ti\"], [\"sh\"]],\n  \"\": [[\"ji\"], [\"g\"]],\n  \"\": [[\"z\"], [\"j\"]],\n  \"\": [[\"y\"], [\"wn\"]],\n  \"\": [[\"zng\"], [\"zhng\"]],\n  \"\": [[\"zi\"], [\"f\"]],\n  \"\": [[\"y\"], [\"ch\"]],\n  \"\": [[\"zu\"], [\"qi\"]],\n  \"\": [[\"w\"], [\"m\"]],\n  \"\": [[\"m\"], [\"rng\"]],\n  \"\": [[\"tu\"], [\"b\"]],\n  \"\": [[\"ling\"], [\"qi\"]],\n  \"\": [[\"g\"], [\"ling\"]],\n  \"\": [[\"u\"], [\"yng\"]],\n  \"\": [[\"dun\"], [\"gn\"]],\n  \"\": [[\"chn\"], [\"y\"]],\n  \"\": [[\"q\"], [\"dio\"]],\n  \"\": [[\"tn\"], [\"ti\"]],\n  \"\": [[\"p\"], [\"yng\"]],\n  \"\": [[\"shn\"], [\"t\"]],\n  \"\": [[\"bi\"], [\"l\"]],\n  \"\": [[\"hung\"], [\"p\"]],\n  \"\": [[\"dun\"], [\"m\"]],\n  \"\": [[\"d\"], [\"w\"]],\n  \"\": [[\"yng\"], [\"sh\"]],\n  \"\": [[\"x\"], [\"mn\"]],\n  \"\": [[\"zh\"], [\"g\"]],\n  \"\": [[\"h\"], [\"lin\"]],\n  \"\": [[\"xun\"], [\"yun\"]],\n  \"\": [[\"zhng\"], [\"l\"]],\n  \"\": [[\"zhng\"], [\"sn\"]],\n  \"\": [[\"wn\"], [\"rn\"]],\n  \"\": [[\"l\"], [\"qi\"]],\n  \"\": [[\"zhun\"], [\"sn\"]],\n  \"\": [[\"xin\"], [\"y\"]],\n};\n","module.exports = {\n\"a\":\"\",\n\"\":\"\",\n\"\":\"\",\n\"\":\"\",\n\"\":\"\",\n\"i\":\"\",\n\"i\":\"\",\n\"i\":\"\",\n\"i\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"ng\":\"\",\n\"ng\":\"\",\n\"ng\":\"\",\n\"ng\":\"\",\n\"o\":\"\",\n\"o\":\"\",\n\"o\":\"\",\n\"o\":\"\",\n\"ba\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"bi\":\"\",\n\"bi\":\"\",\n\"bi\":\"\",\n\"bi\":\"\",\n\"bn\":\"\",\n\"bn\":\"\",\n\"bn\":\"\",\n\"bng\":\"\",\n\"bng\":\"\",\n\"bng\":\"\",\n\"bo\":\"\",\n\"bo\":\"\",\n\"bo\":\"\",\n\"bo\":\"\",\n\"bei\":\"\",\n\"bi\":\"\",\n\"bi\":\"\",\n\"bi\":\"\",\n\"bn\":\"\",\n\"bn\":\"\",\n\"bn\":\"\",\n\"bng\":\"\",\n\"bng\":\"\",\n\"bng\":\"\",\n\"bng\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"bin\":\"\",\n\"bin\":\"\",\n\"bin\":\"\",\n\"bio\":\"\",\n\"bio\":\"\",\n\"bio\":\"\",\n\"bio\":\"\",\n\"bi\":\"\",\n\"bi\":\"\",\n\"bi\":\"\",\n\"bi\":\"\",\n\"bn\":\"\",\n\"bn\":\"\",\n\"bn\":\"\",\n\"bng\":\"\",\n\"bng\":\"\",\n\"bng\":\"\",\n\"bo\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"b\":\"\",\n\"c\":\"\",\n\"c\":\"\",\n\"c\":\"\",\n\"ci\":\"\",\n\"ci\":\"\",\n\"ci\":\"\",\n\"ci\":\"\",\n\"cn\":\"\",\n\"cn\":\"\",\n\"cn\":\"\",\n\"cn\":\"\",\n\"cng\":\"\",\n\"cng\":\"\",\n\"cng\":\"\",\n\"co\":\"\",\n\"co\":\"\",\n\"co\":\"\",\n\"co\":\"\",\n\"c\":\"\",\n\"cn\":\"\",\n\"cn\":\"\",\n\"cng\":\"\",\n\"cng\":\"\",\n\"cng\":\"\",\n\"c\":\"\",\n\"c\":\"\",\n\"c\":\"\",\n\"c\":\"\",\n\"cng\":\"\",\n\"cng\":\"\",\n\"cng\":\"\",\n\"cng\":\"\",\n\"cu\":\"\",\n\"cu\":\"\",\n\"cu\":\"\",\n\"cu\":\"\",\n\"c\":\"\",\n\"c\":\"\",\n\"c\":\"\",\n\"c\":\"\",\n\"cun\":\"\",\n\"cun\":\"\",\n\"cun\":\"\",\n\"cu\":\"\",\n\"cu\":\"\",\n\"cu\":\"\",\n\"cn\":\"\",\n\"cn\":\"\",\n\"cn\":\"\",\n\"cn\":\"\",\n\"cu\":\"\",\n\"cu\":\"\",\n\"cu\":\"\",\n\"cu\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"chi\":\"\",\n\"chi\":\"\",\n\"chi\":\"\",\n\"chi\":\"\",\n\"chn\":\"\",\n\"chn\":\"\",\n\"chn\":\"\",\n\"chn\":\"\",\n\"chng\":\"\",\n\"chng\":\"\",\n\"chng\":\"\",\n\"chng\":\"\",\n\"cho\":\"\",\n\"cho\":\"\",\n\"cho\":\"\",\n\"cho\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"chen\":\"\",\n\"chn\":\"\",\n\"chn\":\"\",\n\"chn\":\"\",\n\"chn\":\"\",\n\"chng\":\"\",\n\"chng\":\"\",\n\"chng\":\"\",\n\"chng\":\"\",\n\"chi\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"chng\":\"\",\n\"chng\":\"\",\n\"chng\":\"\",\n\"chng\":\"\",\n\"chou\":\"\",\n\"chu\":\"\",\n\"chu\":\"\",\n\"chu\":\"\",\n\"chu\":\"\",\n\"chu\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"ch\":\"\",\n\"chu\":\"\",\n\"chu\":\"\",\n\"chu\":\"\",\n\"chui\":\"\",\n\"chui\":\"\",\n\"chui\":\"\",\n\"chui\":\"\",\n\"chun\":\"\",\n\"chun\":\"\",\n\"chun\":\"\",\n\"chun\":\"\",\n\"chung\":\"\",\n\"chung\":\"\",\n\"chung\":\"\",\n\"chung\":\"\",\n\"chu\":\"\",\n\"chu\":\"\",\n\"chu\":\"\",\n\"chu\":\"\",\n\"chn\":\"\",\n\"chn\":\"\",\n\"chn\":\"\",\n\"chu\":\"\",\n\"chu\":\"\",\n\"da\":\"\",\n\"d\":\"\",\n\"d\":\"\",\n\"d\":\"\",\n\"d\":\"\",\n\"di\":\"\",\n\"di\":\"\",\n\"di\":\"\",\n\"dn\":\"\",\n\"dn\":\"\",\n\"dn\":\"\",\n\"dng\":\"\",\n\"dng\":\"\",\n\"dng\":\"\",\n\"do\":\"\",\n\"do\":\"\",\n\"do\":\"\",\n\"do\":\"\",\n\"de\":\"\",\n\"d\":\"\",\n\"d\":\"\",\n\"di\":\"\",\n\"di\":\"\",\n\"dn\":\"\",\n\"dng\":\"\",\n\"dng\":\"\",\n\"dng\":\"\",\n\"d\":\"\",\n\"d\":\"\",\n\"d\":\"\",\n\"d\":\"\",\n\"di\":\"\",\n\"din\":\"\",\n\"din\":\"\",\n\"din\":\"\",\n\"din\":\"\",\n\"dio\":\"\",\n\"dio\":\"\",\n\"dio\":\"\",\n\"di\":\"\",\n\"di\":\"\",\n\"di\":\"\",\n\"di\":\"\",\n\"dng\":\"\",\n\"dng\":\"\",\n\"dng\":\"\",\n\"di\":\"\",\n\"dng\":\"\",\n\"dng\":\"\",\n\"dng\":\"\",\n\"du\":\"\",\n\"du\":\"\",\n\"du\":\"\",\n\"du\":\"\",\n\"d\":\"\",\n\"d\":\"\",\n\"d\":\"\",\n\"d\":\"\",\n\"dun\":\"\",\n\"dun\":\"\",\n\"dun\":\"\",\n\"du\":\"\",\n\"du\":\"\",\n\"du\":\"\",\n\"dn\":\"\",\n\"dn\":\"\",\n\"dn\":\"\",\n\"duo\":\"\",\n\"du\":\"\",\n\"du\":\"\",\n\"du\":\"\",\n\"du\":\"\",\n\"\":\"\",\n\"\":\"\",\n\"\":\"\",\n\"\":\"\",\n\"i\":\"\",\n\"i\":\"\",\n\"i\":\"\",\n\"i\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"ng\":\"\",\n\"r\":\"\",\n\"r\":\"\",\n\"r\":\"\",\n\"f\":\"\",\n\"f\":\"\",\n\"f\":\"\",\n\"f\":\"\",\n\"fn\":\"\",\n\"fn\":\"\",\n\"fn\":\"\",\n\"fn\":\"\",\n\"fng\":\"\",\n\"fng\":\"\",\n\"fng\":\"\",\n\"fng\":\"\",\n\"fi\":\"\",\n\"fi\":\"\",\n\"fi\":\"\",\n\"fi\":\"\",\n\"fn\":\"\",\n\"fn\":\"\",\n\"fn\":\"\",\n\"fn\":\"\",\n\"fng\":\"\",\n\"fng\":\"\",\n\"fng\":\"\",\n\"fng\":\"\",\n\"f\":\"\",\n\"fu\":\"\",\n\"fu\":\"\",\n\"fu\":\"\",\n\"f\":\"\",\n\"f\":\"\",\n\"f\":\"\",\n\"f\":\"\",\n\"g\":\"\",\n\"g\":\"\",\n\"g\":\"\",\n\"g\":\"\",\n\"gi\":\"\",\n\"gi\":\"\",\n\"gi\":\"\",\n\"gn\":\"\",\n\"gn\":\"\",\n\"gn\":\"\",\n\"gng\":\"\",\n\"gng\":\"\",\n\"gng\":\"\",\n\"go\":\"\",\n\"go\":\"\",\n\"go\":\"\",\n\"g\":\"\",\n\"g\":\"\",\n\"g\":\"\",\n\"g\":\"\",\n\"gi\":\"\",\n\"gn\":\"\",\n\"gn\":\"\",\n\"gn\":\"\",\n\"gn\":\"\",\n\"gng\":\"\",\n\"gng\":\"\",\n\"gng\":\"\",\n\"gng\":\"\",\n\"gng\":\"\",\n\"gng\":\"\",\n\"gu\":\"\",\n\"gu\":\"\",\n\"gu\":\"\",\n\"g\":\"\",\n\"g\":\"\",\n\"g\":\"\",\n\"g\":\"\",\n\"gu\":\"\",\n\"gu\":\"\",\n\"gu\":\"\",\n\"gu\":\"\",\n\"gui\":\"\",\n\"gui\":\"\",\n\"gui\":\"\",\n\"gui\":\"\",\n\"gun\":\"\",\n\"gun\":\"\",\n\"gun\":\"\",\n\"gung\":\"\",\n\"gung\":\"\",\n\"gung\":\"\",\n\"gu\":\"\",\n\"gu\":\"\",\n\"gu\":\"\",\n\"gn\":\"\",\n\"gn\":\"\",\n\"guo\":\"\",\n\"gu\":\"\",\n\"gu\":\"\",\n\"gu\":\"\",\n\"gu\":\"\",\n\"h\":\"\",\n\"h\":\"\",\n\"h\":\"\",\n\"h\":\"\",\n\"hi\":\"\",\n\"hi\":\"\",\n\"hi\":\"\",\n\"hi\":\"\",\n\"han\":\"\",\n\"hn\":\"\",\n\"hn\":\"\",\n\"hn\":\"\",\n\"hn\":\"\",\n\"hng\":\"\",\n\"hng\":\"\",\n\"hng\":\"\",\n\"ho\":\"\",\n\"ho\":\"\",\n\"ho\":\"\",\n\"ho\":\"\",\n\"h\":\"\",\n\"h\":\"\",\n\"h\":\"\",\n\"h\":\"\",\n\"hi\":\"\",\n\"hn\":\"\",\n\"hn\":\"\",\n\"hn\":\"\",\n\"hng\":\"\",\n\"hng\":\"\",\n\"hng\":\"\",\n\"hng\":\"\",\n\"hng\":\"\",\n\"hng\":\"\",\n\"hng\":\"\",\n\"hng\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"h\":\"\",\n\"h\":\"\",\n\"h\":\"\",\n\"h\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"hui\":\"\",\n\"hui\":\"\",\n\"hun\":\"\",\n\"hun\":\"\",\n\"hun\":\"\",\n\"hun\":\"\",\n\"hung\":\"\",\n\"hung\":\"\",\n\"hung\":\"\",\n\"hung\":\"\",\n\"hui\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"hn\":\"\",\n\"hn\":\"\",\n\"hn\":\"\",\n\"hn\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"hu\":\"\",\n\"j\":\"\",\n\"j\":\"\",\n\"j\":\"\",\n\"j\":\"\",\n\"jia\":\"\",\n\"ji\":\"\",\n\"ji\":\"\",\n\"ji\":\"\",\n\"ji\":\"\",\n\"jin\":\"\",\n\"jin\":\"\",\n\"jin\":\"\",\n\"jing\":\"\",\n\"jing\":\"\",\n\"jing\":\"\",\n\"jio\":\"\",\n\"jio\":\"\",\n\"jio\":\"\",\n\"jio\":\"\",\n\"jie\":\"\",\n\"ji\":\"\",\n\"ji\":\"\",\n\"ji\":\"\",\n\"ji\":\"\",\n\"jn\":\"\",\n\"jn\":\"\",\n\"jn\":\"\",\n\"jng\":\"\",\n\"jng\":\"\",\n\"jng\":\"\",\n\"jing\":\"\",\n\"jing\":\"\",\n\"jing\":\"\",\n\"ji\":\"\",\n\"ji\":\"\",\n\"ji\":\"\",\n\"ji\":\"\",\n\"j\":\"\",\n\"j\":\"\",\n\"j\":\"\",\n\"j\":\"\",\n\"jun\":\"\",\n\"jun\":\"\",\n\"jun\":\"\",\n\"ju\":\"\",\n\"ju\":\"\",\n\"ju\":\"\",\n\"ju\":\"\",\n\"jn\":\"\",\n\"jn\":\"\",\n\"jn\":\"\",\n\"k\":\"\",\n\"k\":\"\",\n\"ki\":\"\",\n\"ki\":\"\",\n\"ki\":\"\",\n\"kn\":\"\",\n\"kn\":\"\",\n\"kn\":\"\",\n\"kng\":\"\",\n\"kng\":\"\",\n\"kng\":\"\",\n\"kng\":\"\",\n\"ko\":\"\",\n\"ko\":\"\",\n\"ko\":\"\",\n\"k\":\"\",\n\"k\":\"\",\n\"k\":\"\",\n\"k\":\"\",\n\"ki\":\"\",\n\"kn\":\"\",\n\"kn\":\"\",\n\"kn\":\"\",\n\"kng\":\"\",\n\"kng\":\"\",\n\"kng\":\"\",\n\"kng\":\"\",\n\"kng\":\"\",\n\"ku\":\"\",\n\"ku\":\"\",\n\"ku\":\"\",\n\"k\":\"\",\n\"k\":\"\",\n\"k\":\"\",\n\"k\":\"\",\n\"ku\":\"\",\n\"ku\":\"\",\n\"ku\":\"\",\n\"kui\":\"\",\n\"kui\":\"\",\n\"kun\":\"\",\n\"kun\":\"\",\n\"kun\":\"\",\n\"kung\":\"\",\n\"kung\":\"\",\n\"kung\":\"\",\n\"kung\":\"\",\n\"ku\":\"\",\n\"ku\":\"\",\n\"ku\":\"\",\n\"ku\":\"\",\n\"kn\":\"\",\n\"kn\":\"\",\n\"kn\":\"\",\n\"ku\":\"\",\n\"la\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"ln\":\"\",\n\"ln\":\"\",\n\"ln\":\"\",\n\"lng\":\"\",\n\"lng\":\"\",\n\"lng\":\"\",\n\"lng\":\"\",\n\"lo\":\"\",\n\"lo\":\"\",\n\"lo\":\"\",\n\"lo\":\"\",\n\"le\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"lei\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"lng\":\"\",\n\"lng\":\"\",\n\"lng\":\"\",\n\"lng\":\"\",\n\"li\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"li\":\"\",\n\"lin\":\"\",\n\"lin\":\"\",\n\"lin\":\"\",\n\"ling\":\"\",\n\"ling\":\"\",\n\"ling\":\"\",\n\"ling\":\"\",\n\"lio\":\"\",\n\"lio\":\"\",\n\"lio\":\"\",\n\"lio\":\"\",\n\"lie\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"ln\":\"\",\n\"ln\":\"\",\n\"ln\":\"\",\n\"ln\":\"\",\n\"lng\":\"\",\n\"lng\":\"\",\n\"lng\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"li\":\"\",\n\"lo\":\"\",\n\"lng\":\"\",\n\"lng\":\"\",\n\"lng\":\"\",\n\"lou\":\"\",\n\"lu\":\"\",\n\"lu\":\"\",\n\"lu\":\"\",\n\"lu\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"lun\":\"\",\n\"lun\":\"\",\n\"lun\":\"\",\n\"ln\":\"\",\n\"ln\":\"\",\n\"ln\":\"\",\n\"ln\":\"\",\n\"luo\":\"\",\n\"lu\":\"\",\n\"lu\":\"\",\n\"lu\":\"\",\n\"lu\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"l\":\"\",\n\"ma\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"mi\":\"\",\n\"mi\":\"\",\n\"mi\":\"\",\n\"mn\":\"\",\n\"mn\":\"\",\n\"mn\":\"\",\n\"mn\":\"\",\n\"mng\":\"\",\n\"mng\":\"\",\n\"mng\":\"\",\n\"mng\":\"\",\n\"mo\":\"\",\n\"mo\":\"\",\n\"mo\":\"\",\n\"mo\":\"\",\n\"me\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"mi\":\"\",\n\"mi\":\"\",\n\"mi\":\"\",\n\"mn\":\"\",\n\"mn\":\"\",\n\"mn\":\"\",\n\"mng\":\"\",\n\"mng\":\"\",\n\"mng\":\"\",\n\"mng\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"min\":\"\",\n\"min\":\"\",\n\"min\":\"\",\n\"mio\":\"\",\n\"mio\":\"\",\n\"mio\":\"\",\n\"mio\":\"\",\n\"mi\":\"\",\n\"mi\":\"\",\n\"mi\":\"\",\n\"mn\":\"\",\n\"mn\":\"\",\n\"mng\":\"\",\n\"mng\":\"\",\n\"mng\":\"\",\n\"mi\":\"\",\n\"mi\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"mu\":\"\",\n\"mu\":\"\",\n\"mu\":\"\",\n\"mu\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"m\":\"\",\n\"n\":\"\",\n\"\":\"\",\n\"\":\"\",\n\"na\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"ni\":\"\",\n\"ni\":\"\",\n\"ni\":\"\",\n\"nn\":\"\",\n\"nn\":\"\",\n\"nn\":\"\",\n\"nn\":\"\",\n\"nng\":\"\",\n\"nng\":\"\",\n\"nng\":\"\",\n\"nng\":\"\",\n\"no\":\"\",\n\"no\":\"\",\n\"no\":\"\",\n\"no\":\"\",\n\"ne\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"ni\":\"\",\n\"ni\":\"\",\n\"ni\":\"\",\n\"nn\":\"\",\n\"nng\":\"\",\n\"nng\":\"\",\n\"nng\":\"\",\n\"g\":\"\",\n\"g\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"nin\":\"\",\n\"nin\":\"\",\n\"nin\":\"\",\n\"nin\":\"\",\n\"ning\":\"\",\n\"ning\":\"\",\n\"ning\":\"\",\n\"nio\":\"\",\n\"nio\":\"\",\n\"ni\":\"\",\n\"ni\":\"\",\n\"ni\":\"\",\n\"ni\":\"\",\n\"nn\":\"\",\n\"nn\":\"\",\n\"nng\":\"\",\n\"nng\":\"\",\n\"nng\":\"\",\n\"ni\":\"\",\n\"ni\":\"\",\n\"ni\":\"\",\n\"ni\":\"\",\n\"nng\":\"\",\n\"nng\":\"\",\n\"nng\":\"\",\n\"nu\":\"\",\n\"nu\":\"\",\n\"nu\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"nun\":\"\",\n\"nun\":\"\",\n\"nun\":\"\",\n\"nu\":\"\",\n\"nu\":\"\",\n\"nu\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"n\":\"\",\n\"o\":\"\",\n\"\":\"\",\n\"\":\"\",\n\"\":\"\",\n\"\":\"\",\n\"ou\":\"\",\n\"u\":\"\",\n\"u\":\"\",\n\"u\":\"\",\n\"u\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"pi\":\"\",\n\"pi\":\"\",\n\"pi\":\"\",\n\"pi\":\"\",\n\"pn\":\"\",\n\"pn\":\"\",\n\"pn\":\"\",\n\"pn\":\"\",\n\"png\":\"\",\n\"png\":\"\",\n\"png\":\"\",\n\"png\":\"\",\n\"po\":\"\",\n\"po\":\"\",\n\"po\":\"\",\n\"po\":\"\",\n\"pi\":\"\",\n\"pi\":\"\",\n\"pi\":\"\",\n\"pi\":\"\",\n\"pn\":\"\",\n\"pn\":\"\",\n\"pn\":\"\",\n\"pn\":\"\",\n\"png\":\"\",\n\"png\":\"\",\n\"png\":\"\",\n\"png\":\"\",\n\"pi\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"pin\":\"\",\n\"pin\":\"\",\n\"pin\":\"\",\n\"pin\":\"\",\n\"pio\":\"\",\n\"pio\":\"\",\n\"pio\":\"\",\n\"pio\":\"\",\n\"pi\":\"\",\n\"pi\":\"\",\n\"pi\":\"\",\n\"pn\":\"\",\n\"pn\":\"\",\n\"pn\":\"\",\n\"pn\":\"\",\n\"png\":\"\",\n\"png\":\"\",\n\"png\":\"\",\n\"png\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"pu\":\"\",\n\"pu\":\"\",\n\"pu\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"p\":\"\",\n\"qi\":\"\",\n\"q\":\"\",\n\"q\":\"\",\n\"q\":\"\",\n\"q\":\"\",\n\"qi\":\"\",\n\"qi\":\"\",\n\"qi\":\"\",\n\"qi\":\"\",\n\"qin\":\"\",\n\"qin\":\"\",\n\"qin\":\"\",\n\"qin\":\"\",\n\"qing\":\"\",\n\"qing\":\"\",\n\"qing\":\"\",\n\"qing\":\"\",\n\"qio\":\"\",\n\"qio\":\"\",\n\"qio\":\"\",\n\"qio\":\"\",\n\"qi\":\"\",\n\"qi\":\"\",\n\"qi\":\"\",\n\"qi\":\"\",\n\"qn\":\"\",\n\"qn\":\"\",\n\"qn\":\"\",\n\"qn\":\"\",\n\"qng\":\"\",\n\"qng\":\"\",\n\"qng\":\"\",\n\"qng\":\"\",\n\"qing\":\"\",\n\"qing\":\"\",\n\"qing\":\"\",\n\"qi\":\"\",\n\"qi\":\"\",\n\"qi\":\"\",\n\"qi\":\"\",\n\"q\":\"\",\n\"q\":\"\",\n\"q\":\"\",\n\"q\":\"\",\n\"qun\":\"\",\n\"qun\":\"\",\n\"qun\":\"\",\n\"qun\":\"\",\n\"qu\":\"\",\n\"qu\":\"\",\n\"qu\":\"\",\n\"qn\":\"\",\n\"qn\":\"\",\n\"qn\":\"\",\n\"rn\":\"\",\n\"rn\":\"\",\n\"rn\":\"\",\n\"rng\":\"\",\n\"rng\":\"\",\n\"rng\":\"\",\n\"rng\":\"\",\n\"ro\":\"\",\n\"ro\":\"\",\n\"ro\":\"\",\n\"r\":\"\",\n\"r\":\"\",\n\"r\":\"\",\n\"rn\":\"\",\n\"rn\":\"\",\n\"rn\":\"\",\n\"rng\":\"\",\n\"rng\":\"\",\n\"r\":\"\",\n\"rng\":\"\",\n\"rng\":\"\",\n\"rng\":\"\",\n\"ru\":\"\",\n\"ru\":\"\",\n\"ru\":\"\",\n\"r\":\"\",\n\"r\":\"\",\n\"r\":\"\",\n\"r\":\"\",\n\"run\":\"\",\n\"run\":\"\",\n\"run\":\"\",\n\"ru\":\"\",\n\"ru\":\"\",\n\"ru\":\"\",\n\"rn\":\"\",\n\"rn\":\"\",\n\"rn\":\"\",\n\"ru\":\"\",\n\"ru\":\"\",\n\"sa\":\"\",\n\"s\":\"\",\n\"s\":\"\",\n\"s\":\"\",\n\"si\":\"\",\n\"si\":\"\",\n\"si\":\"\",\n\"san\":\"\",\n\"sn\":\"\",\n\"sn\":\"\",\n\"sn\":\"\",\n\"sng\":\"\",\n\"sng\":\"\",\n\"sng\":\"\",\n\"so\":\"\",\n\"so\":\"\",\n\"so\":\"\",\n\"s\":\"\",\n\"s\":\"\",\n\"sn\":\"\",\n\"sn\":\"\",\n\"sng\":\"\",\n\"sng\":\"\",\n\"s\":\"\",\n\"s\":\"\",\n\"s\":\"\",\n\"s\":\"\",\n\"sng\":\"\",\n\"sng\":\"\",\n\"sng\":\"\",\n\"sng\":\"\",\n\"su\":\"\",\n\"su\":\"\",\n\"su\":\"\",\n\"s\":\"\",\n\"s\":\"\",\n\"s\":\"\",\n\"s\":\"\",\n\"sun\":\"\",\n\"sun\":\"\",\n\"sun\":\"\",\n\"su\":\"\",\n\"su\":\"\",\n\"su\":\"\",\n\"su\":\"\",\n\"sn\":\"\",\n\"sn\":\"\",\n\"sn\":\"\",\n\"su\":\"\",\n\"su\":\"\",\n\"su\":\"\",\n\"su\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"shi\":\"\",\n\"shi\":\"\",\n\"shi\":\"\",\n\"shn\":\"\",\n\"shn\":\"\",\n\"shn\":\"\",\n\"shn\":\"\",\n\"shang\":\"\",\n\"shng\":\"\",\n\"shng\":\"\",\n\"shng\":\"\",\n\"sho\":\"\",\n\"sho\":\"\",\n\"sho\":\"\",\n\"sho\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"shi\":\"\",\n\"shn\":\"\",\n\"shn\":\"\",\n\"shn\":\"\",\n\"shn\":\"\",\n\"shng\":\"\",\n\"shng\":\"\",\n\"shng\":\"\",\n\"shng\":\"\",\n\"shi\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"shu\":\"\",\n\"shu\":\"\",\n\"shu\":\"\",\n\"shu\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"sh\":\"\",\n\"shu\":\"\",\n\"shu\":\"\",\n\"shu\":\"\",\n\"shui\":\"\",\n\"shui\":\"\",\n\"shui\":\"\",\n\"shun\":\"\",\n\"shun\":\"\",\n\"shung\":\"\",\n\"shung\":\"\",\n\"shung\":\"\",\n\"shu\":\"\",\n\"shu\":\"\",\n\"shu\":\"\",\n\"shn\":\"\",\n\"shn\":\"\",\n\"shu\":\"\",\n\"shu\":\"\",\n\"ta\":\"\",\n\"t\":\"\",\n\"t\":\"\",\n\"t\":\"\",\n\"t\":\"\",\n\"ti\":\"\",\n\"ti\":\"\",\n\"ti\":\"\",\n\"ti\":\"\",\n\"tn\":\"\",\n\"tn\":\"\",\n\"tn\":\"\",\n\"tn\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"to\":\"\",\n\"to\":\"\",\n\"to\":\"\",\n\"to\":\"\",\n\"t\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"t\":\"\",\n\"t\":\"\",\n\"t\":\"\",\n\"t\":\"\",\n\"tin\":\"\",\n\"tin\":\"\",\n\"tin\":\"\",\n\"tin\":\"\",\n\"tio\":\"\",\n\"tio\":\"\",\n\"tio\":\"\",\n\"tio\":\"\",\n\"ti\":\"\",\n\"ti\":\"\",\n\"ti\":\"\",\n\"ti\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"tng\":\"\",\n\"tou\":\"\",\n\"tu\":\"\",\n\"tu\":\"\",\n\"tu\":\"\",\n\"tu\":\"\",\n\"tu\":\"\",\n\"t\":\"\",\n\"t\":\"\",\n\"t\":\"\",\n\"t\":\"\",\n\"tun\":\"\",\n\"tun\":\"\",\n\"tun\":\"\",\n\"tun\":\"\",\n\"tu\":\"\",\n\"tu\":\"\",\n\"tu\":\"\",\n\"tu\":\"\",\n\"tn\":\"\",\n\"tn\":\"\",\n\"tn\":\"\",\n\"tn\":\"\",\n\"tu\":\"\",\n\"tu\":\"\",\n\"tu\":\"\",\n\"tu\":\"\",\n\"wa\":\"\",\n\"w\":\"\",\n\"w\":\"\",\n\"w\":\"\",\n\"w\":\"\",\n\"wai\":\"\",\n\"wi\":\"\",\n\"wi\":\"\",\n\"wi\":\"\",\n\"wn\":\"\",\n\"wn\":\"\",\n\"wn\":\"\",\n\"wn\":\"\",\n\"wng\":\"\",\n\"wng\":\"\",\n\"wng\":\"\",\n\"wng\":\"\",\n\"wi\":\"\",\n\"wi\":\"\",\n\"wi\":\"\",\n\"wi\":\"\",\n\"wn\":\"\",\n\"wn\":\"\",\n\"wn\":\"\",\n\"wn\":\"\",\n\"wng\":\"\",\n\"wng\":\"\",\n\"wng\":\"\",\n\"w\":\"\",\n\"w\":\"\",\n\"w\":\"\",\n\"w\":\"\",\n\"w\":\"\",\n\"w\":\"\",\n\"w\":\"\",\n\"x\":\"\",\n\"x\":\"\",\n\"x\":\"\",\n\"x\":\"\",\n\"xi\":\"\",\n\"xi\":\"\",\n\"xi\":\"\",\n\"xi\":\"\",\n\"xin\":\"\",\n\"xin\":\"\",\n\"xin\":\"\",\n\"xin\":\"\",\n\"xing\":\"\",\n\"xing\":\"\",\n\"xing\":\"\",\n\"xing\":\"\",\n\"xio\":\"\",\n\"xio\":\"\",\n\"xio\":\"\",\n\"xio\":\"\",\n\"xi\":\"\",\n\"xi\":\"\",\n\"xi\":\"\",\n\"xi\":\"\",\n\"xn\":\"\",\n\"xn\":\"\",\n\"xn\":\"\",\n\"xn\":\"\",\n\"xng\":\"\",\n\"xng\":\"\",\n\"xng\":\"\",\n\"xng\":\"\",\n\"xing\":\"\",\n\"xing\":\"\",\n\"xing\":\"\",\n\"xing\":\"\",\n\"xi\":\"\",\n\"xi\":\"\",\n\"xi\":\"\",\n\"xi\":\"\",\n\"x\":\"\",\n\"x\":\"\",\n\"x\":\"\",\n\"x\":\"\",\n\"xun\":\"\",\n\"xun\":\"\",\n\"xun\":\"\",\n\"xun\":\"\",\n\"xu\":\"\",\n\"xu\":\"\",\n\"xu\":\"\",\n\"xu\":\"\",\n\"xn\":\"\",\n\"xn\":\"\",\n\"xn\":\"\",\n\"ya\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"yn\":\"\",\n\"yn\":\"\",\n\"yn\":\"\",\n\"yn\":\"\",\n\"yng\":\"\",\n\"yng\":\"\",\n\"yng\":\"\",\n\"yng\":\"\",\n\"yo\":\"\",\n\"yo\":\"\",\n\"yo\":\"\",\n\"yo\":\"\",\n\"ye\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"yi\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"yn\":\"\",\n\"yn\":\"\",\n\"yn\":\"\",\n\"yn\":\"\",\n\"yng\":\"\",\n\"yng\":\"\",\n\"yng\":\"\",\n\"yng\":\"\",\n\"yo\":\"\",\n\"y\":\"\",\n\"yng\":\"\",\n\"yng\":\"\",\n\"yng\":\"\",\n\"yng\":\"\",\n\"yu\":\"\",\n\"yu\":\"\",\n\"yu\":\"\",\n\"yu\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"y\":\"\",\n\"yun\":\"\",\n\"yun\":\"\",\n\"yun\":\"\",\n\"yun\":\"\",\n\"yu\":\"\",\n\"yu\":\"\",\n\"yu\":\"\",\n\"yn\":\"\",\n\"yn\":\"\",\n\"yn\":\"\",\n\"yn\":\"\",\n\"z\":\"\",\n\"z\":\"\",\n\"z\":\"\",\n\"zi\":\"\",\n\"zi\":\"\",\n\"zi\":\"\",\n\"zn\":\"\",\n\"zn\":\"\",\n\"zn\":\"\",\n\"zn\":\"\",\n\"zng\":\"\",\n\"zng\":\"\",\n\"zng\":\"\",\n\"zo\":\"\",\n\"zo\":\"\",\n\"zo\":\"\",\n\"zo\":\"\",\n\"z\":\"\",\n\"z\":\"\",\n\"zi\":\"\",\n\"zn\":\"\",\n\"zn\":\"\",\n\"zn\":\"\",\n\"zng\":\"\",\n\"zng\":\"\",\n\"zng\":\"\",\n\"zi\":\"\",\n\"z\":\"\",\n\"z\":\"\",\n\"z\":\"\",\n\"z\":\"\",\n\"zng\":\"\",\n\"zng\":\"\",\n\"zng\":\"\",\n\"zu\":\"\",\n\"zu\":\"\",\n\"zu\":\"\",\n\"z\":\"\",\n\"z\":\"\",\n\"z\":\"\",\n\"z\":\"\",\n\"zun\":\"\",\n\"zun\":\"\",\n\"zun\":\"\",\n\"zu\":\"\",\n\"zu\":\"\",\n\"zu\":\"\",\n\"zu\":\"\",\n\"zn\":\"\",\n\"zn\":\"\",\n\"zn\":\"\",\n\"zuo\":\"\",\n\"zu\":\"\",\n\"zu\":\"\",\n\"zu\":\"\",\n\"zu\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zhi\":\"\",\n\"zhi\":\"\",\n\"zhi\":\"\",\n\"zhi\":\"\",\n\"zhn\":\"\",\n\"zhn\":\"\",\n\"zhn\":\"\",\n\"zhn\":\"\",\n\"zhng\":\"\",\n\"zhng\":\"\",\n\"zhng\":\"\",\n\"zho\":\"\",\n\"zho\":\"\",\n\"zho\":\"\",\n\"zho\":\"\",\n\"zhe\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zhi\":\"\",\n\"zhn\":\"\",\n\"zhn\":\"\",\n\"zhn\":\"\",\n\"zhn\":\"\",\n\"zhng\":\"\",\n\"zhng\":\"\",\n\"zhng\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zhng\":\"\",\n\"zhng\":\"\",\n\"zhng\":\"\",\n\"zhu\":\"\",\n\"zhu\":\"\",\n\"zhu\":\"\",\n\"zhu\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zh\":\"\",\n\"zhu\":\"\",\n\"zhu\":\"\",\n\"zhui\":\"\",\n\"zhui\":\"\",\n\"zhui\":\"\",\n\"zhun\":\"\",\n\"zhun\":\"\",\n\"zhun\":\"\",\n\"zhung\":\"\",\n\"zhung\":\"\",\n\"zhung\":\"\",\n\"zhu\":\"\",\n\"zhu\":\"\",\n\"zhu\":\"\",\n\"zhn\":\"\",\n\"zhn\":\"\",\n\"zhn\":\"\",\n\"zhu\":\"\",\n\"zhu\":\"\",\n\"zhu\":\"\",\n\"chng,n,hn\": \"\",\n\"dng,zhng\": \"\",\n\"b,bo\": \"\",\n\"j,j\": \"\",\n\"le,lio\": \"\",\n\"gn,gn\": \"\",\n\"d,di,ti\": \"\",\n\"y,y,y\": \"\",\n\"shng,shng\": \"\",\n\"wn,m\": \"\",\n\"g,g\": \"\",\n\"me,m,ma,yo\": \"\",\n\"gung,n\": \"\",\n\"wng,w\": \"\",\n\"n,r\": \"\",\n\"ch,ch,ch\": \"\",\n\"wng,wng\": \"\",\n\"f,f\": \"\",\n\"zh,z,zh\": \"\",\n\"b,fu\": \"\",\n\"q,u\": \"\",\n\"ch,j\": \"\",\n\"qi,qi\": \"\",\n\"w,w\": \"\",\n\"tn,zhn\": \"\",\n\"sho,sho\": \"\",\n\"zhng,zhng\": \"\",\n\"ni,n\": \"\",\n\"jin,xin\": \"\",\n\"chng,zhng\": \"\",\n\"shn,sh\": \"\",\n\"pin,pin\": \"\",\n\"p,p\": \"\",\n\"hu,hu\": \"\",\n\"chu,qi\": \"\",\n\"zhu,zho\": \"\",\n\"jn,jn\": \"\",\n\"f,f\": \"\",\n\"cng,zng\": \"\",\n\"fn,fn\": \"\",\n\"sh,zh\": \"\",\n\"fng,fng\": \"\",\n\"gu,gu\": \"\",\n\"li,l\": \"\",\n\"du,du\": \"\",\n\"wi,wi\": \"\",\n\"ch,ch\": \"\",\n\"y,y\": \"\",\n\"d,d\": \"\",\n\"zhng,zhng\": \"\",\n\"b,p\": \"\",\n\"ji,ji\": \"\",\n\"sh,sh,zh\": \"\",\n\"k,k\": \"\",\n\"sh,dn\": \"\",\n\"k,qi\": \"\",\n\"bi,bi\": \"\",\n\"zhn,zhn\": \"\",\n\"qi,j\": \"\",\n\"y,xi\": \"\",\n\"ho,ho\": \"\",\n\"zh,zh\": \"\",\n\"do,to\": \"\",\n\"zi,z,z\": \"\",\n\"lng,lng,lng\": \"\",\n\"l,yu\": \"\",\n\"j,gu\": \"\",\n\"ch,ch\": \"\",\n\"tu,tou\": \"\",\n\"nng,nng,zh\": \"\",\n\"zho,sho\": \"\",\n\"f,f\": \"\",\n\"ti,ti\": \"\",\n\"kng,gng\": \"\",\n\"d,de\": \"\",\n\"so,so\": \"\",\n\"chng,chng\": \"\",\n\"p,p,p,pio\": \"\",\n\"gu,guo,gu\": \"\",\n\"y,y\": \"\",\n\"yu,yu\": \"\",\n\"ku,ku\": \"\",\n\"xi,y,y,y,x\": \"\",\n\"ji,ji,g,xi\": \"\",\n\"hu,hu\": \"\",\n\"dng,dng\": \"\",\n\"t,t\": \"\",\n\"xi,h\": \"\",\n\"tng,tng\": \"\",\n\"q,q\": \"\",\n\"ma,m,m\": \"\",\n\"q,ki\": \"\",\n\"zh,sh\": \"\",\n\"chun,zhun\": \"\",\n\"xi,x\": \"\",\n\"rn,rn\": \"\",\n\"hu,hu,hu\": \"\",\n\"ji,ji,jie\": \"\",\n\"fn,bn\": \"\",\n\"yng,ng\": \"\",\n\"xi,xu\": \"\",\n\"s,sh\": \"\",\n\"hng,xng\": \"\",\n\"hu,kui\": \"\",\n\"h,g\": \"\",\n\"chung,chung\": \"\",\n\"chng,chng\": \"\",\n\"q,j,z,zhi\": \"\",\n\"yng,xing\": \"\",\n\"bng,bng\": \"\",\n\"hn,hn\": \"\",\n\"tng,shng\": \"\",\n\"xng,xng\": \"\",\n\"x,h\": \"\",\n\"ln,ln\": \"\",\n\"n,n,ni,n\": \"\",\n\"jn,jn\": \"\",\n\"sn,xn\": \"\",\n\"x,h\": \"\",\n\"ho,ho\": \"\",\n\"t,ji\": \"\",\n\"gun,gun\": \"\",\n\"hng,gng\": \"\",\n\"xin,qin\": \"\",\n\"j,j\": \"\",\n\"yu,yo\": \"\",\n\"nng,lng\": \"\",\n\"yun,yun\": \"\",\n\"hui,pi,p,pi\": \"\",\n\"zh,sh,zh\": \"\",\n\"qing,qing,chng\": \"\",\n\"k,qio\": \"\",\n\"fng,fng\": \"\",\n\"b,b\": \"\",\n\"gn,gn\": \"\",\n\"s,s\": \"\",\n\"gng,gng\": \"\",\n\"gng,gng\": \"\",\n\"l,l\": \"\",\n\"hi,hun\": \"\",\n\"fu,p\": \"\",\n\"xin,xun\": \"\",\n\"zh,ch\": \"\",\n\"ya,y\": \"\",\n\"cho,cho\": \"\",\n\"yun,yn,yn\": \"\",\n\"ba,b\": \"\",\n\"bi,bi\": \"\",\n\"dng,dng\": \"\",\n\"g,g\": \"\",\n\"h,h,h\": \"\",\n\"t,t,bn\": \"\",\n\"b,bi,b\": \"\",\n\"yng,yng\": \"\",\n\"f,f,b,b\": \"\",\n\"d,d\": \"\",\n\"gu,jn,qi\": \"\",\n\"jio,ju\": \"\",\n\"tio,tio\": \"\",\n\"x,j\": \"\",\n\"yng,yng\": \"\",\n\"zh,zhi\": \"\",\n\"jin,jin\": \"\",\n\"mn,mn\": \"\",\n\"d,t,tu\": \"\",\n\"sh,sh\": \"\",\n\"sh,sh\": \"\",\n\"mi,m\": \"\",\n\"shn,chn\": \"\",\n\"sh,zh\": \"\",\n\"nio,su\": \"\",\n\"wi,y\": \"\",\n\",\": \"\",\n\"jn,jng\": \"\",\n\"zng,zng\": \"\",\n\"wn,wn\": \"\",\n\"m,m,m\": \"\",\n\"dn,dn,dn\": \"\",\n\"chi,c\": \"\",\n\"j,gu\": \"\",\n\"l,l\": \"\",\n\"bn,pn\": \"\",\n\"z,zhi\": \"\",\n\"q,j\": \"\",\n\"ru,r\": \"\",\n\"png,png\": \"\",\n\"zh,q\": \"\",\n\"gu,j\": \"\",\n\"sng,sng\": \"\",\n\"c,c\": \"\",\n\"y,y\": \"\",\n\"bn,bn\": \"\",\n\"q,q\": \"\",\n\"zhun,zhun,zhui\": \"\",\n\"xi,su\": \"\",\n\"ne,n\": \"\",\n\"ti,ti,ti,\": \"\",\n\"lng,lng\": \"\",\n\"zh,zh\": \"\",\n\"h,h,hu,hu,h\": \"\",\n\"gng,gng\": \"\",\n\"wi,wi\": \"\",\n\"c,z,zhi\": \"\",\n\"p,pi\": \"\",\n\"de,d,d\": \"\",\n\"ci,ci\": \"\",\n\"f,f\": \"\",\n\"d,de\": \"\",\n\"jng,chng\": \"\",\n\"jun,jun\": \"\",\n\"qun,xun\": \"\",\n\"dn,shn,chn\": \"\",\n\"qin,jin\": \"\",\n\"xi,y\": \"\",\n\"p,b\": \"\",\n\"po,po\": \"\",\n\"n,n\": \"\",\n\"z,sh\": \"\",\n\"kng,kng,kng\": \"\",\n\"lng,lng\": \"\",\n\"xing,yng\": \"\",\n\"l,di\": \"\",\n\"shu,shu\": \"\",\n\"jing,xing\": \"\",\n\"cn,shn,cn,sn\": \"\",\n\"d,di\": \"\",\n\"ku,k\": \"\",\n\"dng,dng\": \"\",\n\"ku,gu\": \"\",\n\"sh,sh\": \"\",\n\"tio,tio\": \"\",\n\"shn,shn\": \"\",\n\"xing,hng\": \"\",\n\"nn,n\": \"\",\n\"xing,xing\": \"\",\n\"ch,zh\": \"\",\n\"bi,b,b\": \"\",\n\"yo,yo\": \"\",\n\"yn,yn\": \"\",\n\"q,qi\": \"\",\n\"bi,bi\": \"\",\n\"shng,xng\": \"\",\n\"xio,xu\": \"\",\n\"hng,hng,hng\": \"\",\n\"mo,m\": \"\",\n\"y,y\": \"\",\n\"s,si\": \"\",\n\"m,m,m\": \"\",\n\"hu,hu\": \"\",\n\"y,yn,yn\": \"\",\n\"zn,z\": \"\",\n\"h,h,h\": \"\",\n\"n,ni,na,n\": \"\",\n\"hi,k\": \"\",\n\"g,g\": \"\",\n\"gng,gng\": \"\",\n\"yo,yu\": \"\",\n\"kn,kn\": \"\",\n\"zhng,zhng,chng\": \"\",\n\"bin,pin\": \"\",\n\"zhng,chng\": \"\",\n\"xn,shn\": \"\",\n\"zhu,du\": \"\",\n\"di,di\": \"\",\n\"sh,s,y\": \"\",\n\"mi,m\": \"\",\n\"jing,jing\": \"\",\n\"d,du\": \"\",\n\"qn,qng\": \"\",\n\"ch,ch,chi,c\": \"\",\n\"zh,zh\": \"\",\n\"po,po,bo\": \"\",\n\"s,x\": \"\",\n\"x,xin\": \"\",\n\"ju,jio\": \"\",\n\"bin,pin\": \"\",\n\"shu,shu,yu\": \"\",\n\"lo,m\": \"\",\n\"gi,j\": \"\",\n\"lu,lo\": \"\",\n\"zi,zi\": \"\",\n\"mi,mn\": \"\",\n\"sho,sho\": \"\",\n\"d,du\": \"\",\n\"i,i\": \"\",\n\"m,m\": \"\",\n\",w,,w\": \"\",\n\"xio,jio\": \"\",\n\"h,h\": \"\",\n\"yn,yn\": \"\",\n\"hung,hung\": \"\",\n\"i,i\": \"\",\n\",,,,a\": \"\",\n\"b,ba,p\": \"\",\n\"zun,zun\": \"\",\n\"qin,yn\": \"\",\n\"chng,shng\": \"\",\n\"m,b\": \"\",\n\"chng,chn,chng\": \"\",\n\"do,do\": \"\",\n\"tng,chng\": \"\",\n\"chng,chng\": \"\",\n\"chu,xi\": \"\",\n\"sh,y,y\": \"\",\n\"g,g\": \"\",\n\"shui,cu\": \"\",\n\"ling,ling\": \"\",\n\"ch,x\": \"\",\n\"png,bng\": \"\",\n\"zhng,zhng\": \"\",\n\"yng,chng\": \"\",\n\"qio,qio\": \"\",\n\"ji,jia,jie\": \"\",\n\"d,du\": \"\",\n\"shn,shn\": \"\",\n\"shn,shn\": \"\",\n\"bi,p\": \"\",\n\"tio,dio,zhu\": \"\",\n\"b,bo\": \"\",\n\"nng,ni\": \"\",\n\"nn,nn,nu\": \"\",\n\"pi,pi\": \"\",\n\"jio,jio\": \"\",\n\"j,j\": \"\",\n\"zh,zhu,zhe\": \"\",\n\"jn,jn\": \"\",\n\"l,li\": \"\",\n\"sho,so\": \"\",\n\"f,p\": \"\",\n\"pio,pio\": \"\",\n\"shng,chng\": \"\",\n\"qu,qio,qio\": \"\",\n\"ch,shi\": \"\",\n\"m,m\": \"\",\n\"la,l\": \"\",\n\"sh,y\": \"\",\n\"li,li,li\": \"\",\n\"zhn,chn\": \"\",\n\"qun,jun,jun\": \"\",\n\"lng,lng\": \"\",\n\"d,di,de\": \"\",\n\"ji,ji\": \"\",\n\"mo,mo\": \"\",\n\"xun,xun\": \"\",\n\"zhe,zhu,zho,zho\": \"\",\n\"l,shui\": \"\",\n\"gi,g,h\": \"\",\n\"ln,ln\": \"\",\n\"q,j\": \"\",\n\"jin,jin\": \"\",\n\"hn,hn\": \"\",\n\"s,xi,xi\": \"\",\n\"tn,dn\": \"\",\n\"yn,yn\": \"\",\n\"jng,gng\": \"\",\n\"l,l\": \"\",\n\"q,c\": \"\",\n\"t,d,d\": \"\",\n\"ji,q\": \"\",\n\"lu,lu\": \"\",\n\"q,j\": \"\",\n\"sn,sn\": \"\",\n\"g,g\": \"\",\n\"zho,cho\": \"\",\n\"lu,l,lo\": \"\",\n\"y,y\": \"\",\n\"gn,hn\": \"\",\n\"zh,shi\": \"\",\n\"xi,sh\": \"\",\n\"li,li\": \"\",\n\"jng,yng\": \"\",\n\"pn,pn\": \"\",\n\"po,po\": \"\",\n\"h,h,y\": \"\",\n\"p,p\": \"\",\n\"zh,zh\": \"\",\n\"d,d\": \"\",\n\"bo,b,p\": \"\",\n\"o,y\": \"\",\n\"fn,pn\": \"\",\n\"l,x\": \"\",\n\"gng,jing\": \"\",\n\"cng,zng\": \"\",\n\"y,tu\": \"\",\n\"qing,qing,jing\": \"\",\n\"sh,zh\": \"\",\n\"zhu,y\": \"\",\n\"sh,ni\": \"\",\n\"tin,zhn\": \"\",\n\"mng,mng,mng\": \"\",\n\"jn,jn\": \"\",\n\"l,li\": \"\",\n\"tio,to\": \"\",\n\",y\": \"\",\n\"ji,ji,xi\": \"\",\n\"sh,sh,shu\": \"\",\n\"li,li\": \"\",\n\"si,si,s\": \"\",\n\"p,b\": \"\",\n\"fng,fng\": \"\",\n\"pi,pi\": \"\",\n\"m,m\": \"\",\n\"bng,bng\": \"\",\n\"shang,chng\": \"\",\n\"xin,xin\": \"\",\n\"y,n\": \"\",\n\"go,go\": \"\",\n\"pio,pio,pio\": \"\",\n\"su,s\": \"\",\n\"q,c\": \"\",\n\"s,s\": \"\",\n\"tng,tng\": \"\",\n\"hng,hng\": \"\",\n\"mn,mn\": \"\",\n\"bo,p\": \"\",\n\"m,m\": \"\",\n\"h,h,h\": \"\",\n\"p,p\": \"\",\n\"yn,yn\": \"\",\n\"bo,b,b\": \"\",\n\"m,m\": \"\",\n\"jio,zhu\": \"\",\n\"cng,zng\": \"\",\n\"fn,p\": \"\",\n\"b,bei\": \"\",\n\"chn,zhn\": \"\",\n\"jing,qing\": \"\",\n\"jio,ju,jio\": \"\",\n\"rng,rng\": \"\",\n\"l,lu\": \"\",\n\"nng,nng\": \"\",\n\"hng,bn\": \"\",\n\"o,w\": \"\",\n\"fng,png\": \"\",\n\"x,y\": \"\",\n\"li,l\": \"\",\n\"ln,ln\": \"\",\n\"ji,gi\": \"\",\n\"xn,xn\": \"\",\n\"ch,ch\": \"\",\n\"xio,xio\": \"\",\n\"zh,z\": \"\",\n\"u,u,u\": \"\",\n\"n,n\": \"\",\n\"qing,qing\": \"\",\n\"tn,dn\": \"\",\n\"kng,hng\": \"\",\n\"din,tin\": \"\",\n\"s,c\": \"\",\n\"din,tin,shng\": \"\",\n\"po,bo\": \"\",\n\"du,ru,yu\": \"\",\n\"k,k\": \"\",\n\"tu,t,zh\": \"\",\n\"f,b\": \"\",\n\"nng,nng,nng\": \"\",\n\"o,o,ni\": \"\",\n\"k,h\": \"\",\n\"yn,yn\": \"\",\n\"h,a,k\": \"\",\n\"g,k\": \"\",\n\"jio,yo\": \"\",\n\"ch,sh\": \"\",\n\"n,yo\": \"\",\n\"mng,mng\": \"\",\n\"g,y\": \"\",\n\"j,j\": \"\",\n\"z,c\": \"\",\n\"wn,yun\": \"\",\n\"m,m\": \"\",\n\"q,qi,xi\": \"\",\n\"xi,ji\": \"\",\n\"du,du\": \"\",\n\"zh,shn,shi,c\": \"\",\n\"b,bi\": \"\",\n\"zhu,zhu\": \"\",\n\"li,li,li,lie\": \"\",\n\"yo,y\": \"\",\n\"qio,xio\": \"\",\n\"hu,hu\": \"\",\n\"png,bng\": \"\",\n\"n,nu\": \"\",\n\"p,b\": \"\",\n\"q,x\": \"\",\n\"ji,g\": \"\",\n\"lo,lo\": \"\",\n\"bng,bng\": \"\",\n\"gng,zhng\": \"\",\n\"li,l,l\": \"\",\n\"ju,ju\": \"\",\n\"yn,yn,yn\": \"\",\n\"w,gu\": \"\",\n\"lo,lu\": \"\",\n\"nin,ni\": \"\",\n\"y,y\": \"\",\n\"chn,xin,cn,shn\": \"\",\n\"dn,shn\": \"\",\n\"fi,fi\": \"\",\n\"qin,gn\": \"\",\n\"shu,sh\": \"\",\n\"lu,lu,luo\": \"\",\n\"h,xi\": \"\",\n\"dng,chng\": \"\",\n\"xin,x\": \"\",\n\"jio,jio\": \"\",\n\"ku,gu\": \"\",\n\"j,zhi\": \"\",\n\"tng,chng\": \"\",\n\"chn,zhn\": \"\",\n\"wi,y\": \"\",\n\"du,hu\": \"\",\n\"chu,cho\": \"\",\n\"bng,bng,bng\": \"\",\n\"zng,zng\": \"\",\n\"zhu,zu\": \"\",\n\"chui,chui,chui,tun,zhu\": \"\",\n\"png,bng\": \"\",\n\"zhu,chu\": \"\",\n\"lng,lng,lng\": \"\",\n\"qio,qio\": \"\",\n\"zh,ch\": \"\",\n\"h,g\": \"\",\n\"qin,kn\": \"\",\n\"yn,\": \"\",\n\"dn,du\": \"\",\n\"ku,hu\": \"\",\n\"so,so\": \"\",\n\"ki,ji\": \"\",\n\"pn,bn\": \"\",\n\"li,li\": \"\",\n\"n,nio\": \"\",\n\"jio,cho\": \"\",\n\"o,o\": \"\",\n\"mn,wn\": \"\",\n\"ch,ch\": \"\",\n\"xn,xn\": \"\",\n\"da,d\": \"\",\n\"tu,tn\": \"\",\n\"lio,lio\": \"\",\n\"cu,zu\": \"\",\n\"cho,zho\": \"\",\n\"hi,m\": \"\",\n\"zhung,chung\": \"\",\n\"j,q\": \"\",\n\"bi,bi\": \"\",\n\"lio,lo,lo\": \"\",\n\"chng,dng\": \"\",\n\"li,li\": \"\",\n\"m,m\": \"\",\n\"lio,lio\": \"\",\n\"lio,lio\": \"\",\n\"so,so\": \"\",\n\"m,mi\": \"\",\n\"hu,hu,hu\": \"\",\n\"p,bo\": \"\",\n\"zn,cun\": \"\",\n\"b,b\": \"\",\n\"b,b\": \"\",\n}","// @see [](https://zh.wikipedia.org/wiki/%E7%99%BE%E5%AE%B6%E5%A7%93)\nmodule.exports = {\n  \"\": [[\"zho\"]],\n  \"\": [[\"qin\"]],\n  \"\": [[\"sn\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"zhu\"]],\n  \"\": [[\"w\"]],\n  \"\": [[\"zhng\"]],\n  \"\": [[\"wng\"]],\n  \"\": [[\"fng\"]],\n  \"\": [[\"chn\"]],\n  \"\": [[\"ch\"]],\n  \"\": [[\"wi\"]],\n  \"\": [[\"jing\"]],\n  \"\": [[\"shn\"]],\n  \"\": [[\"hn\"]],\n  \"\": [[\"yng\"]],\n  \"\": [[\"zh\"]],\n  \"\": [[\"qn\"]],\n  \"\": [[\"yu\"]],\n  \"\": [[\"x\"]],\n  \"\": [[\"h\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"sh\"]],\n  \"\": [[\"zhng\"]],\n  \"\": [[\"kng\"]],\n  \"\": [[\"co\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"hu\"]],\n  \"\": [[\"jn\"]],\n  \"\": [[\"wi\"]],\n  \"\": [[\"to\"]],\n  \"\": [[\"jing\"]],\n  \"\": [[\"q\"]],\n  \"\": [[\"xi\"]],\n  \"\": [[\"zu\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"bi\"]],\n  \"\": [[\"shu\"]],\n  \"\": [[\"du\"]],\n  \"\": [[\"zhng\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"s\"]],\n  \"\": [[\"pn\"]],\n  \"\": [[\"g\"]],\n  \"\": [[\"x\"]],\n  \"\": [[\"fn\"]],\n  \"\": [[\"png\"]],\n  \"\": [[\"lng\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"wi\"]],\n  \"\": [[\"chng\"]],\n  \"\": [[\"m\"]],\n  \"\": [[\"mio\"]],\n  \"\": [[\"fng\"]],\n  \"\": [[\"hu\"]],\n  \"\": [[\"fng\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"rn\"]],\n  \"\": [[\"yun\"]],\n  \"\": [[\"li\"]],\n  \"\": [[\"fng\"]],\n  \"\": [[\"bo\"]],\n  \"\": [[\"sh\"]],\n  \"\": [[\"tng\"]],\n  \"\": [[\"fi\"]],\n  \"\": [[\"lin\"]],\n  \"\": [[\"cn\"]],\n  \"\": [[\"xu\"]],\n  \"\": [[\"li\"]],\n  \"\": [[\"h\"]],\n  \"\": [[\"n\"]],\n  \"\": [[\"tng\"]],\n  \"\": [[\"tng\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"lu\"]],\n  \"\": [[\"b\"]],\n  \"\": [[\"ho\"]],\n  \"\": [[\"w\"]],\n  \"\": [[\"n\"]],\n  \"\": [[\"chng\"]],\n  \"\": [[\"yu\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"sh\"]],\n  \"\": [[\"f\"]],\n  \"\": [[\"p\"]],\n  \"\": [[\"bin\"]],\n  \"\": [[\"q\"]],\n  \"\": [[\"kng\"]],\n  \"\": [[\"w\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"yun\"]],\n  \"\": [[\"b\"]],\n  \"\": [[\"g\"]],\n  \"\": [[\"mng\"]],\n  \"\": [[\"png\"]],\n  \"\": [[\"hung\"]],\n  \"\": [[\"h\"]],\n  \"\": [[\"m\"]],\n  \"\": [[\"xio\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"yo\"]],\n  \"\": [[\"sho\"]],\n  \"\": [[\"zhn\"]],\n  \"\": [[\"wng\"]],\n  \"\": [[\"q\"]],\n  \"\": [[\"mo\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"d\"]],\n  \"\": [[\"m\"]],\n  \"\": [[\"bi\"]],\n  \"\": [[\"mng\"]],\n  \"\": [[\"zng\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"f\"]],\n  \"\": [[\"chng\"]],\n  \"\": [[\"di\"]],\n  \"\": [[\"tn\"]],\n  \"\": [[\"sng\"]],\n  \"\": [[\"mo\"]],\n  \"\": [[\"png\"]],\n  \"\": [[\"xing\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"sh\"]],\n  \"\": [[\"q\"]],\n  \"\": [[\"xing\"]],\n  \"\": [[\"zh\"]],\n  \"\": [[\"dng\"]],\n  \"\": [[\"ling\"]],\n  \"\": [[\"d\"]],\n  \"\": [[\"run\"]],\n  \"\": [[\"ln\"]],\n  \"\": [[\"mn\"]],\n  \"\": [[\"x\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"m\"]],\n  \"\": [[\"qing\"]],\n  \"\": [[\"ji\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"lu\"]],\n  \"\": [[\"wi\"]],\n  \"\": [[\"jing\"]],\n  \"\": [[\"tng\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"gu\"]],\n  \"\": [[\"mi\"]],\n  \"\": [[\"shng\"]],\n  \"\": [[\"ln\"]],\n  \"\": [[\"dio\"]],\n  \"\": [[\"zhng\"]],\n  \"\": [[\"x\"]],\n  \"\": [[\"qi\"]],\n  \"\": [[\"lu\"]],\n  \"\": [[\"go\"]],\n  \"\": [[\"xi\"]],\n  \"\": [[\"ci\"]],\n  \"\": [[\"tin\"]],\n  \"\": [[\"fn\"]],\n  \"\": [[\"h\"]],\n  \"\": [[\"lng\"]],\n  \"\": [[\"hu\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"wn\"]],\n  \"\": [[\"zh\"]],\n  \"\": [[\"k\"]],\n  \"\": [[\"zn\"]],\n  \"\": [[\"gun\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"m\"]],\n  \"\": [[\"jng\"]],\n  \"\": [[\"fng\"]],\n  \"\": [[\"qi\"]],\n  \"\": [[\"mio\"]],\n  \"\": [[\"gn\"]],\n  \"\": [[\"xi\"]],\n  \"\": [[\"yng\"]],\n  \"\": [[\"zng\"]],\n  \"\": [[\"dng\"]],\n  \"\": [[\"xun\"]],\n  \"\": [[\"bn\"]],\n  \"\": [[\"dng\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"shn\"]],\n  \"\": [[\"hng\"]],\n  \"\": [[\"hng\"]],\n  \"\": [[\"bo\"]],\n  \"\": [[\"zh\"]],\n  \"\": [[\"zu\"]],\n  \"\": [[\"sh\"]],\n  \"\": [[\"cu\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"ni\"]],\n  \"\": [[\"gng\"]],\n  \"\": [[\"chng\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"xng\"]],\n  \"\": [[\"hu\"]],\n  \"\": [[\"pi\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"rng\"]],\n  \"\": [[\"wng\"]],\n  \"\": [[\"xn\"]],\n  \"\": [[\"yng\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"hu\"]],\n  \"\": [[\"zhn\"]],\n  \"\": [[\"q\"]],\n  \"\": [[\"ji\"]],\n  \"\": [[\"fng\"]],\n  \"\": [[\"ru\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"ch\"]],\n  \"\": [[\"jn\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"bng\"]],\n  \"\": [[\"m\"]],\n  \"\": [[\"sng\"]],\n  \"\": [[\"jng\"]],\n  \"\": [[\"dun\"]],\n  \"\": [[\"f\"]],\n  \"\": [[\"w\"]],\n  \"\": [[\"w\"]],\n  \"\": [[\"jio\"]],\n  \"\": [[\"b\"]],\n  \"\": [[\"gng\"]],\n  \"\": [[\"m\"]],\n  \"\": [[\"ku\"]],\n  \"\": [[\"shn\"]],\n  \"\": [[\"g\"]],\n  \"\": [[\"ch\"]],\n  \"\": [[\"hu\"]],\n  \"\": [[\"m\"]],\n  \"\": [[\"png\"]],\n  \"\": [[\"qun\"]],\n  \"\": [[\"x\"]],\n  \"\": [[\"bn\"]],\n  \"\": [[\"yng\"]],\n  \"\": [[\"qi\"]],\n  \"\": [[\"zhng\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"gng\"]],\n  \"\": [[\"nng\"]],\n  \"\": [[\"qi\"]],\n  \"\": [[\"lun\"]],\n  \"\": [[\"bo\"]],\n  \"\": [[\"gn\"]],\n  \"\": [[\"tu\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"rng\"]],\n  \"\": [[\"z\"]],\n  \"\": [[\"w\"]],\n  \"\": [[\"f\"]],\n  \"\": [[\"li\"]],\n  \"\": [[\"jng\"]],\n  \"\": [[\"zhn\"]],\n  \"\": [[\"sh\"]],\n  \"\": [[\"lng\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"xng\"]],\n  \"\": [[\"s\"]],\n  \"\": [[\"sho\"]],\n  \"\": [[\"go\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"b\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"s\"]],\n  \"\": [[\"bi\"]],\n  \"\": [[\"hui\"]],\n  \"\": [[\"p\"]],\n  \"\": [[\"ti\"]],\n  \"\": [[\"cng\"]],\n  \"\": [[\"\"]],\n  \"\": [[\"su\"]],\n  \"\": [[\"xin\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"li\"]],\n  \"\": [[\"zhu\"]],\n  \"\": [[\"ln\"]],\n  \"\": [[\"t\"]],\n  \"\": [[\"mng\"]],\n  \"\": [[\"ch\"]],\n  \"\": [[\"qio\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"x\"]],\n  \"\": [[\"ni\"]],\n  \"\": [[\"cng\"]],\n  \"\": [[\"shung\"]],\n  \"\": [[\"wn\"]],\n  \"\": [[\"shn\"]],\n  \"\": [[\"dng\"]],\n  \"\": [[\"zhi\"]],\n  \"\": [[\"tn\"]],\n  \"\": [[\"gng\"]],\n  \"\": [[\"lo\"]],\n  \"\": [[\"png\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"shn\"]],\n  \"\": [[\"f\"]],\n  \"\": [[\"d\"]],\n  \"\": [[\"rn\"]],\n  \"\": [[\"zi\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"yng\"]],\n  \"\": [[\"x\"]],\n  \"\": [[\"q\"]],\n  \"\": [[\"sng\"]],\n  \"\": [[\"gu\"]],\n  \"\": [[\"p\"]],\n  \"\": [[\"ni\"]],\n  \"\": [[\"shu\"]],\n  \"\": [[\"tng\"]],\n  \"\": [[\"bin\"]],\n  \"\": [[\"h\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"ji\"]],\n  \"\": [[\"p\"]],\n  \"\": [[\"shng\"]],\n  \"\": [[\"nng\"]],\n  \"\": [[\"wn\"]],\n  \"\": [[\"bi\"]],\n  \"\": [[\"zhung\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"chi\"]],\n  \"\": [[\"q\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"chng\"]],\n  \"\": [[\"m\"]],\n  \"\": [[\"lin\"]],\n  \"\": [[\"r\"]],\n  \"\": [[\"x\"]],\n  \"\": [[\"hun\"]],\n  \"\": [[\"i\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"rng\"]],\n  \"\": [[\"xing\"]],\n  \"\": [[\"g\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"shn\"]],\n  \"\": [[\"g\"]],\n  \"\": [[\"lio\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"zhng\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"hng\"]],\n  \"\": [[\"b\"]],\n  \"\": [[\"d\"]],\n  \"\": [[\"gng\"]],\n  \"\": [[\"mn\"]],\n  \"\": [[\"hng\"]],\n  \"\": [[\"kung\"]],\n  \"\": [[\"gu\"]],\n  \"\": [[\"wn\"]],\n  \"\": [[\"ku\"]],\n  \"\": [[\"gung\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"qu\"]],\n  \"\": [[\"dng\"]],\n  \"\": [[\"u\"]],\n  \"\": [[\"sh\"]],\n  \"\": [[\"w\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"wi\"]],\n  \"\": [[\"yu\"]],\n  \"\": [[\"ku\"]],\n  \"\": [[\"lng\"]],\n  \"\": [[\"sh\"]],\n  \"\": [[\"gng\"]],\n  \"\": [[\"sh\"]],\n  \"\": [[\"ni\"]],\n  \"\": [[\"cho\"]],\n  \"\": [[\"gu\"]],\n  \"\": [[\"o\"]],\n  \"\": [[\"rng\"]],\n  \"\": [[\"lng\"]],\n  \"\": [[\"z\"]],\n  \"\": [[\"xn\"]],\n  \"\": [[\"kn\"]],\n  \"\": [[\"n\"]],\n  \"\": [[\"jin\"]],\n  \"\": [[\"ro\"]],\n  \"\": [[\"kng\"]],\n  \"\": [[\"zng\"]],\n  \"\": [[\"m\"]],\n  \"\": [[\"sh\"]],\n  \"\": [[\"ni\"]],\n  \"\": [[\"yng\"]],\n  \"\": [[\"j\"]],\n  \"\": [[\"x\"]],\n  \"\": [[\"fng\"]],\n  \"\": [[\"cho\"]],\n  \"\": [[\"gun\"]],\n  \"\": [[\"kui\"]],\n  \"\": [[\"xing\"]],\n  \"\": [[\"zh\"]],\n  \"\": [[\"hu\"]],\n  \"\": [[\"jng\"]],\n  \"\": [[\"hng\"]],\n  \"\": [[\"yu\"]],\n  \"\": [[\"zh\"]],\n  \"\": [[\"qun\"]],\n  \"\": [[\"l\"]],\n  \"\": [[\"gi\"]],\n  \"\": [[\"y\"]],\n  \"\": [[\"hun\"]],\n  \"\": [[\"gng\"]],\n  \"\": [[\"mu\"]],\n  \"\": [[\"h\"]],\n  \"\": [[\"yn\"]],\n  \"\": [[\"f\"]],\n};\n","// \nmodule.exports = {\n  \"\": \"a1\",\n  \"\": \"a2\",\n  \"\": \"a3\",\n  \"\": \"a4\",\n  \"\": \"e1\",\n  \"\": \"e2\",\n  \"\": \"e3\",\n  \"\": \"e4\",\n  \"\": \"o1\",\n  \"\": \"o2\",\n  \"\": \"o3\",\n  \"\": \"o4\",\n  \"\": \"i1\",\n  \"\": \"i2\",\n  \"\": \"i3\",\n  \"\": \"i4\",\n  \"\": \"u1\",\n  \"\": \"u2\",\n  \"\": \"u3\",\n  \"\": \"u4\",\n  \"\": \"v0\",\n  \"\": \"v2\",\n  \"\": \"v3\",\n  \"\": \"v4\",\n  \"\": \"n2\",\n  \"\": \"n3\",\n  \"\": \"m2\",\n};\n","\"use strict\";\n\nconst assign = require(\"object-assign\");\nconst SurnamePinyinData = require(\"../data/surname\");\nconst CompoundSurnamePinyinData = require(\"../data/compound_surname\");\n\n// XXX: Symbol when web support.\nconst PINYIN_STYLE = {\n  NORMAL: 0,       // \n  TONE: 1,         // \n  TONE2: 2,        //  0~4 \n  TO3NE: 5,        //  0~4 \n  INITIALS: 3,     // \n  FIRST_LETTER: 4, // \n};\n// \nconst PINYIN_MODE = {\n  NORMAL: 0, // \n  SURNAME: 1, // \n  PLACENAME: 2, // \n};\nconst DEFAULT_OPTIONS = {\n  mode: PINYIN_MODE.NORMAL, // \n  style: PINYIN_STYLE.TONE, // \n  segment: false,           // \n  heteronym: false,         // \n};\n\n// \nconst INITIALS = \"b,p,m,f,d,t,n,l,g,k,h,j,q,x,r,zh,ch,sh,z,c,s\".split(\",\");\n// \n//const FINALS = \"ang,eng,ing,ong,an,en,in,un,er,ai,ei,ui,ao,ou,iu,ie,ve,a,o,e,i,u,v\".split(\",\");\n// \nconst PHONETIC_SYMBOL = require(\"./phonetic-symbol\");\nconst RE_PHONETIC_SYMBOL = new RegExp(\"([\" + Object.keys(PHONETIC_SYMBOL).join(\"\") + \"])\", \"g\");\nconst RE_TONE2 = /([aeoiuvnm])([0-4])$/;\nconst util = require(\"./util\");\n\n/*\n * Initials\n * @param {String}\n * @return {String}\n */\nfunction initials(pinyin) {\n  for (let i = 0, l = INITIALS.length; i < l; i++){\n    if (pinyin.indexOf(INITIALS[i]) === 0) {\n      return INITIALS[i];\n    }\n  }\n  return \"\";\n}\n\nclass Pinyin {\n  constructor (dict) {\n    this._dict = dict;\n  }\n\n  // @param {String} hans \n  // @param {Object} options, \n  // @return {Array} \n  convert (hans, options) {\n\n    if (typeof hans !== \"string\") {\n      return [];\n    }\n\n    options = assign({}, DEFAULT_OPTIONS, options);\n\n    let pys = [];\n    let nohans = \"\";\n\n    if (options.mode === PINYIN_MODE.SURNAME) {\n      pys.push(this.surname_pinyin(hans, options));\n    } else {\n\n      for(let i = 0, firstCharCode, words, l = hans.length; i < l; i++) {\n\n        words = hans[i];\n        firstCharCode = words.charCodeAt(0);\n\n        if(this._dict[firstCharCode]) {\n\n          // ends of non-chinese words.\n          if(nohans.length > 0) {\n            pys.push([nohans]);\n            nohans = \"\"; // reset non-chinese words.\n          }\n\n          pys.push(this.single_pinyin(words, options));\n\n        } else {\n          nohans += words;\n        }\n      }\n\n    }\n\n    // \n    if(nohans.length > 0){\n      pys.push([nohans]);\n    }\n\n    Object.defineProperty(pys, \"compact\", {\n      value: util.compact.bind(this, pys),\n      enumerable: false,\n      configurable: false,\n    });\n\n    return pys;\n  }\n\n  // \n  // @param {String} han, \n  // @return {Array} \n  single_pinyin(han, options) {\n\n    if (typeof han !== \"string\") {\n      return [];\n    }\n    if (han.length !== 1) {\n      return this.single_pinyin(han.charAt(0), options);\n    }\n\n    let hanCode = han.charCodeAt(0);\n\n    if (!this._dict[hanCode]) {\n      return [han];\n    }\n\n    let pys = this._dict[hanCode].split(\",\");\n    if(!options.heteronym){\n      return [Pinyin.toFixed(pys[0], options.style)];\n    }\n\n    // \n    let py_cached = {};\n    let pinyins = [];\n    for(let i = 0, py, l = pys.length; i < l; i++){\n      py = Pinyin.toFixed(pys[i], options.style);\n      if(py_cached.hasOwnProperty(py)){\n        continue;\n      }\n      py_cached[py] = py;\n\n      pinyins.push(py);\n    }\n    return pinyins;\n  }\n\n  // \n  surname_pinyin(hans, options) {\n    return this.compound_surname(hans, options);\n  }\n\n  // \n  compound_surname(hans, options) {\n    let len = hans.length;\n    let prefixIndex = 0;\n    let result = [];\n    function toFixed(item) {\n      return item.map(ch => Pinyin.toFixed(ch, options.style));\n    }\n    for (let i = 0; i < len; i++) {\n      const twowords = hans.substring(i, i + 2);\n      if (CompoundSurnamePinyinData.hasOwnProperty(twowords)) {\n        if (prefixIndex <= i - 1) {\n          result = result.concat(\n            this.single_surname(\n              hans.substring(prefixIndex, i),\n              options\n            )\n          );\n        }\n        result = result.concat(CompoundSurnamePinyinData[twowords].map(toFixed));\n\n        i = i + 2;\n        prefixIndex = i;\n      }\n    }\n    // \n    result = result.concat(\n      this.single_surname(\n        hans.substring(prefixIndex, len),\n        options\n      )\n    );\n    return result;\n  }\n\n  // \n  single_surname(hans, options) {\n    let result = [];\n    function toFixed(item) {\n      return item.map(ch => Pinyin.toFixed(ch, options.style));\n    }\n    for (let i = 0, l = hans.length; i < l; i++) {\n      const word = hans.charAt(i);\n      if (SurnamePinyinData.hasOwnProperty(word)) {\n        result = result.concat(SurnamePinyinData[word].map(toFixed));\n      } else {\n        result.push(this.single_pinyin(word, options));\n      }\n    }\n    return result;\n  }\n\n  /**\n   * \n   *\n   * @param {String} pinyin TONE \n   * @param {ENUM} style \n   * @return {String} \n   */\n  static toFixed (pinyin, style) {\n    let tone = \"\"; // \n    let first_letter;\n    let py;\n    switch(style){\n    case PINYIN_STYLE.INITIALS:\n      return initials(pinyin);\n\n    case PINYIN_STYLE.FIRST_LETTER:\n      first_letter = pinyin.charAt(0);\n      if (PHONETIC_SYMBOL.hasOwnProperty(first_letter)) {\n        first_letter = PHONETIC_SYMBOL[first_letter].charAt(0);\n      }\n      return first_letter;\n\n    case PINYIN_STYLE.NORMAL:\n      return pinyin.replace(RE_PHONETIC_SYMBOL, function($0, $1_phonetic){\n        return PHONETIC_SYMBOL[$1_phonetic].replace(RE_TONE2, \"$1\");\n      });\n\n    case PINYIN_STYLE.TO3NE:\n      return pinyin.replace(RE_PHONETIC_SYMBOL, function($0, $1_phonetic){\n        return PHONETIC_SYMBOL[$1_phonetic];\n      });\n\n    case PINYIN_STYLE.TONE2:\n      py = pinyin.replace(RE_PHONETIC_SYMBOL, function($0, $1){\n        // \n        tone = PHONETIC_SYMBOL[$1].replace(RE_TONE2, \"$2\");\n\n        return PHONETIC_SYMBOL[$1].replace(RE_TONE2, \"$1\");\n      });\n      return py + tone;\n\n    case PINYIN_STYLE.TONE:\n    default:\n      return pinyin;\n    }\n  }\n\n  /**\n   * \n   *\n   * @param {String} hanA  A\n   * @return {String} hanB  B\n   * @return {Number}  -10 1\n   */\n  compare (hanA, hanB) {\n    const pinyinA = this.convert(hanA, DEFAULT_OPTIONS);\n    const pinyinB = this.convert(hanB, DEFAULT_OPTIONS);\n    return String(pinyinA).localeCompare(String(pinyinB));\n  }\n\n  compact(arr) {\n    return util.compact(arr);\n  }\n\n  static get STYLE_NORMAL () {\n    return PINYIN_STYLE.NORMAL;\n  }\n  static get STYLE_TONE () {\n    return PINYIN_STYLE.TONE;\n  }\n  static get STYLE_TONE2 () {\n    return PINYIN_STYLE.TONE2;\n  }\n  static get STYLE_TO3NE () {\n    return PINYIN_STYLE.TO3NE;\n  }\n  static get STYLE_INITIALS () {\n    return PINYIN_STYLE.INITIALS;\n  }\n  static get STYLE_FIRST_LETTER () {\n    return PINYIN_STYLE.FIRST_LETTER;\n  }\n  static get MODE_NORMAL () {\n    return PINYIN_MODE.NORMAL;\n  }\n  static get MODE_SURNAME () {\n    return PINYIN_MODE.SURNAME;\n  }\n  static get MODE_PLACENAME () {\n    return PINYIN_MODE.PLACENAME;\n  }\n  static get DEFAULT_OPTIONS () {\n    return DEFAULT_OPTIONS;\n  }\n}\n\nmodule.exports = Pinyin;\n","\"use strict\";\n\n/**\n *  2 \n * @param {Array<String>} a1  [\"zho\", \"cho\"]\n * @param {Array<String>} a2  [\"yng\"]\n * @return {Array<String>}  [\"zhoyng\", \"choyng\"]\n */\nfunction combo2array(a1, a2) {\n  const result = [];\n  if (!a1.length) {\n    return a2;\n  }\n  if (!a2.length) {\n    return a1;\n  }\n  for (let i = 0, l = a1.length; i < l; i++) {\n    for (let j = 0, m = a2.length; j < m; j++) {\n      result.push(a1[i] + a2[j]);\n    }\n  }\n  return result;\n}\n\n/**\n * \n * @param {Array<Array<String>>} arr  [[\"zho\", \"cho\"], [\"yng\"], [\"dng\"], [\"shng\"]]\n * @return {Array<String>} \n *  [\n *    [\"zhoyng\"], [\"dng\"], [\"shng\"],\n *    [\"choyng\"], [\"dng\"], [\"shng\"]\n *  ]\n */\nfunction combo(arr) {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return arr[0];\n  }\n  let result = combo2array(arr[0], arr[1]);\n  for (let i = 2, l = arr.length; i < l; i++) {\n    result = combo2array(result, arr[i]);\n  }\n  return result;\n}\n\n/**\n * \n * @param {string[]|string[][]} arr1 eg: [\"hai\", \"huan\"]\n * @param {Array<String>} arr2 eg: [\"qian\"]\n * @returns {string[][]} eg: [ [\"hai\", \"qian\"], [\"huan\", \"qian\"] ]\n */\nfunction compact2array(a1, a2) {\n  if (!Array.isArray(a1) || !Array.isArray(a2)) {\n    throw new Error(\"compact2array expect two array as parameters\");\n  }\n  if (!a1.length) {\n    a1 = [\"\"];\n  }\n  if (!a2.length) {\n    a2 = [\"\"];\n  }\n  const result = [];\n  for (let i = 0, l = a1.length; i < l; i++) {\n    for (let j = 0, m = a2.length; j < m; j++) {\n      if (Array.isArray(a1[i])) {\n        result.push([...a1[i], a2[j]]);\n      } else {\n        result.push([a1[i], a2[j]]);\n      }\n    }\n  }\n  return result;\n}\n\nfunction compact(arr) {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  let result = compact2array(arr[0], arr[1]);\n  for (let i = 2, l = arr.length; i < l; ++i) {\n    result = compact2array(result, arr[i]);\n  }\n  return result;\n}\n\nexports.combo2array = combo2array;\nexports.combo = combo;\nexports.compact2array = compact2array;\nexports.compact = compact;\n","\"use strict\";\n\n// \n// @param {Object} dict_combo, \n// @param {Object} \nfunction buildPinyinCache(dict_combo){\n  let hans;\n  let uncomboed = {};\n\n  for(let py in dict_combo){\n    hans = dict_combo[py];\n    for(let i = 0, han, l = hans.length; i < l; i++){\n      han = hans.charCodeAt(i);\n      if(!uncomboed.hasOwnProperty(han)){\n        uncomboed[han] = py;\n      }else{\n        uncomboed[han] += \",\" + py;\n      }\n    }\n  }\n\n  return uncomboed;\n}\n\nconst PINYIN_DICT = buildPinyinCache(require(\"../data/dict-zi-web\"));\nconst Pinyin = require(\"./pinyin\");\nconst pinyin = new Pinyin(PINYIN_DICT);\n\nmodule.exports = pinyin.convert.bind(pinyin);\nmodule.exports.compare = pinyin.compare.bind(pinyin);\nmodule.exports.compact = pinyin.compact.bind(pinyin);\nmodule.exports.STYLE_NORMAL = Pinyin.STYLE_NORMAL;\nmodule.exports.STYLE_TONE = Pinyin.STYLE_TONE;\nmodule.exports.STYLE_TONE2 = Pinyin.STYLE_TONE2;\nmodule.exports.STYLE_TO3NE = Pinyin.STYLE_TO3NE;\nmodule.exports.STYLE_INITIALS = Pinyin.STYLE_INITIALS;\nmodule.exports.STYLE_FIRST_LETTER = Pinyin.STYLE_FIRST_LETTER;\n","import { useEffect, useLayoutEffect } from 'react'; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\nexport var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;","import { useReducer, useRef, useMemo, useContext, useDebugValue } from 'react';\nimport { useReduxContext as useDefaultReduxContext } from './useReduxContext';\nimport { createSubscription } from '../utils/Subscription';\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect';\nimport { ReactReduxContext } from '../components/Context';\n\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\n\nfunction useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {\n  var _useReducer = useReducer(function (s) {\n    return s + 1;\n  }, 0),\n      forceRender = _useReducer[1];\n\n  var subscription = useMemo(function () {\n    return createSubscription(store, contextSub);\n  }, [store, contextSub]);\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef();\n  var latestStoreState = useRef();\n  var latestSelectedState = useRef();\n  var storeState = store.getState();\n  var selectedState;\n\n  try {\n    if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {\n      var newSelectedState = selector(storeState); // ensure latest selected state is reused so that a custom equality function can result in identical references\n\n      if (latestSelectedState.current === undefined || !equalityFn(newSelectedState, latestSelectedState.current)) {\n        selectedState = newSelectedState;\n      } else {\n        selectedState = latestSelectedState.current;\n      }\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\" + latestSubscriptionCallbackError.current.stack + \"\\n\\n\";\n    }\n\n    throw err;\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    latestSelector.current = selector;\n    latestStoreState.current = storeState;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(function () {\n    function checkForUpdates() {\n      try {\n        var newStoreState = store.getState(); // Avoid calling selector multiple times if the store's state has not changed\n\n        if (newStoreState === latestStoreState.current) {\n          return;\n        }\n\n        var _newSelectedState = latestSelector.current(newStoreState);\n\n        if (equalityFn(_newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n\n        latestSelectedState.current = _newSelectedState;\n        latestStoreState.current = newStoreState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n\n      forceRender();\n    }\n\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    return function () {\n      return subscription.tryUnsubscribe();\n    };\n  }, [store, subscription]);\n  return selectedState;\n}\n/**\r\n * Hook factory, which creates a `useSelector` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useSelector` hook bound to the specified context.\r\n */\n\n\nexport function createSelectorHook(context) {\n  if (context === void 0) {\n    context = ReactReduxContext;\n  }\n\n  var useReduxContext = context === ReactReduxContext ? useDefaultReduxContext : function () {\n    return useContext(context);\n  };\n  return function useSelector(selector, equalityFn) {\n    if (equalityFn === void 0) {\n      equalityFn = refEquality;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!selector) {\n        throw new Error(\"You must pass a selector to useSelector\");\n      }\n\n      if (typeof selector !== 'function') {\n        throw new Error(\"You must pass a function as a selector to useSelector\");\n      }\n\n      if (typeof equalityFn !== 'function') {\n        throw new Error(\"You must pass a function as an equality function to useSelector\");\n      }\n    }\n\n    var _useReduxContext = useReduxContext(),\n        store = _useReduxContext.store,\n        contextSub = _useReduxContext.subscription;\n\n    var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);\n    useDebugValue(selectedState);\n    return selectedState;\n  };\n}\n/**\r\n * A hook to access the redux store's state. This hook takes a selector function\r\n * as an argument. The selector is called with the store state.\r\n *\r\n * This hook takes an optional equality comparison function as the second parameter\r\n * that allows you to customize the way the selected state is compared to determine\r\n * whether the component needs to be re-rendered.\r\n *\r\n * @param {Function} selector the selector function\r\n * @param {Function=} equalityFn the function that will be used to determine equality\r\n *\r\n * @returns {any} the selected state\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useSelector } from 'react-redux'\r\n *\r\n * export const CounterComponent = () => {\r\n *   const counter = useSelector(state => state.counter)\r\n *   return <div>{counter}</div>\r\n * }\r\n */\n\nexport var useSelector = /*#__PURE__*/createSelectorHook();","// Default to a dummy \"batch\" implementation that just runs the callback\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\nvar batch = defaultNoopBatch; // Allow injecting another batching function later\n\nexport var setBatch = function setBatch(newBatch) {\n  return batch = newBatch;\n}; // Supply a getter just to skip dealing with ESM bindings\n\nexport var getBatch = function getBatch() {\n  return batch;\n};","export * from './exports';\nimport { unstable_batchedUpdates as batch } from './utils/reactBatchedUpdates';\nimport { setBatch } from './utils/batch'; // Enable batched updates in our subscriptions for use\n// with standard React renderers (ReactDOM, React Native)\n\nsetBatch(batch);\nexport { batch };","/**\n * NOTE: If you refactor this to split up the modules into separate files,\n * you'll need to update the rollup config for react-router-dom-v5-compat.\n */\nimport * as React from \"react\";\nimport type {\n  NavigateOptions,\n  RelativeRoutingType,\n  RouteObject,\n  To,\n} from \"react-router\";\nimport {\n  Router,\n  createPath,\n  useHref,\n  useLocation,\n  useMatch,\n  useMatches,\n  useNavigate,\n  useNavigation,\n  useResolvedPath,\n  UNSAFE_DataRouterContext as DataRouterContext,\n  UNSAFE_DataRouterStateContext as DataRouterStateContext,\n  UNSAFE_NavigationContext as NavigationContext,\n  UNSAFE_RouteContext as RouteContext,\n  UNSAFE_enhanceManualRouteObjects as enhanceManualRouteObjects,\n} from \"react-router\";\nimport type {\n  BrowserHistory,\n  Fetcher,\n  FormEncType,\n  FormMethod,\n  GetScrollRestorationKeyFunction,\n  HashHistory,\n  History,\n  HydrationState,\n  Router as RemixRouter,\n} from \"@remix-run/router\";\nimport {\n  createRouter,\n  createBrowserHistory,\n  createHashHistory,\n  invariant,\n  joinPaths,\n  matchPath,\n} from \"@remix-run/router\";\n\nimport type {\n  SubmitOptions,\n  ParamKeyValuePair,\n  URLSearchParamsInit,\n} from \"./dom\";\nimport {\n  createSearchParams,\n  defaultMethod,\n  getFormSubmissionInfo,\n  getSearchParamsForLocation,\n  shouldProcessLinkClick,\n} from \"./dom\";\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Re-exports\n////////////////////////////////////////////////////////////////////////////////\n\nexport type {\n  FormEncType,\n  FormMethod,\n  ParamKeyValuePair,\n  SubmitOptions,\n  URLSearchParamsInit,\n};\nexport { createSearchParams };\n\n// Note: Keep in sync with react-router exports!\nexport type {\n  ActionFunction,\n  ActionFunctionArgs,\n  AwaitProps,\n  DataRouteMatch,\n  DataRouteObject,\n  Fetcher,\n  Hash,\n  IndexRouteObject,\n  IndexRouteProps,\n  JsonFunction,\n  LayoutRouteProps,\n  LoaderFunction,\n  LoaderFunctionArgs,\n  Location,\n  MemoryRouterProps,\n  NavigateFunction,\n  NavigateOptions,\n  NavigateProps,\n  Navigation,\n  Navigator,\n  NonIndexRouteObject,\n  OutletProps,\n  Params,\n  ParamParseKey,\n  Path,\n  PathMatch,\n  Pathname,\n  PathPattern,\n  PathRouteProps,\n  RedirectFunction,\n  RelativeRoutingType,\n  RouteMatch,\n  RouteObject,\n  RouteProps,\n  RouterProps,\n  RouterProviderProps,\n  RoutesProps,\n  Search,\n  ShouldRevalidateFunction,\n  To,\n} from \"react-router\";\nexport {\n  AbortedDeferredError,\n  Await,\n  MemoryRouter,\n  Navigate,\n  NavigationType,\n  Outlet,\n  Route,\n  Router,\n  RouterProvider,\n  Routes,\n  createMemoryRouter,\n  createPath,\n  createRoutesFromChildren,\n  createRoutesFromElements,\n  defer,\n  isRouteErrorResponse,\n  generatePath,\n  json,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  redirect,\n  renderMatches,\n  resolvePath,\n  useActionData,\n  useAsyncError,\n  useAsyncValue,\n  useHref,\n  useInRouterContext,\n  useLoaderData,\n  useLocation,\n  useMatch,\n  useMatches,\n  useNavigate,\n  useNavigation,\n  useNavigationType,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRevalidator,\n  useRouteError,\n  useRouteLoaderData,\n  useRoutes,\n} from \"react-router\";\n\n///////////////////////////////////////////////////////////////////////////////\n// DANGER! PLEASE READ ME!\n// We provide these exports as an escape hatch in the event that you need any\n// routing data that we don't provide an explicit API for. With that said, we\n// want to cover your use case if we can, so if you feel the need to use these\n// we want to hear from you. Let us know what you're building and we'll do our\n// best to make sure we can support you!\n//\n// We consider these exports an implementation detail and do not guarantee\n// against any breaking changes, regardless of the semver release. Use with\n// extreme caution and only if you understand the consequences. Godspeed.\n///////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport {\n  UNSAFE_DataRouterContext,\n  UNSAFE_DataRouterStateContext,\n  UNSAFE_DataStaticRouterContext,\n  UNSAFE_NavigationContext,\n  UNSAFE_LocationContext,\n  UNSAFE_RouteContext,\n  UNSAFE_enhanceManualRouteObjects,\n} from \"react-router\";\n//#endregion\n\ndeclare global {\n  var __staticRouterHydrationData: HydrationState | undefined;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Routers\n////////////////////////////////////////////////////////////////////////////////\n\nexport function createBrowserRouter(\n  routes: RouteObject[],\n  opts?: {\n    basename?: string;\n    hydrationData?: HydrationState;\n    window?: Window;\n  }\n): RemixRouter {\n  return createRouter({\n    basename: opts?.basename,\n    history: createBrowserHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || window?.__staticRouterHydrationData,\n    routes: enhanceManualRouteObjects(routes),\n  }).initialize();\n}\n\nexport function createHashRouter(\n  routes: RouteObject[],\n  opts?: {\n    basename?: string;\n    hydrationData?: HydrationState;\n    window?: Window;\n  }\n): RemixRouter {\n  return createRouter({\n    basename: opts?.basename,\n    history: createHashHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || window?.__staticRouterHydrationData,\n    routes: enhanceManualRouteObjects(routes),\n  }).initialize();\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n\nexport interface BrowserRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  window?: Window;\n}\n\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nexport function BrowserRouter({\n  basename,\n  children,\n  window,\n}: BrowserRouterProps) {\n  let historyRef = React.useRef<BrowserHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({ window, v5Compat: true });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface HashRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  window?: Window;\n}\n\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nexport function HashRouter({ basename, children, window }: HashRouterProps) {\n  let historyRef = React.useRef<HashHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({ window, v5Compat: true });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface HistoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  history: History;\n}\n\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter({ basename, children, history }: HistoryRouterProps) {\n  const [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nif (__DEV__) {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\n\nexport { HistoryRouter as unstable_HistoryRouter };\n\nexport interface LinkProps\n  extends Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, \"href\"> {\n  reloadDocument?: boolean;\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n  to: To;\n}\n\n/**\n * The public API for rendering a history-aware <a>.\n */\nexport const Link = React.forwardRef<HTMLAnchorElement, LinkProps>(\n  function LinkWithRef(\n    {\n      onClick,\n      relative,\n      reloadDocument,\n      replace,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      ...rest\n    },\n    ref\n  ) {\n    let href = useHref(to, { relative });\n    let internalOnClick = useLinkClickHandler(to, {\n      replace,\n      state,\n      target,\n      preventScrollReset,\n      relative,\n    });\n    function handleClick(\n      event: React.MouseEvent<HTMLAnchorElement, MouseEvent>\n    ) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented) {\n        internalOnClick(event);\n      }\n    }\n\n    return (\n      // eslint-disable-next-line jsx-a11y/anchor-has-content\n      <a\n        {...rest}\n        href={href}\n        onClick={reloadDocument ? onClick : handleClick}\n        ref={ref}\n        target={target}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  Link.displayName = \"Link\";\n}\n\nexport interface NavLinkProps\n  extends Omit<LinkProps, \"className\" | \"style\" | \"children\"> {\n  children?:\n    | React.ReactNode\n    | ((props: { isActive: boolean; isPending: boolean }) => React.ReactNode);\n  caseSensitive?: boolean;\n  className?:\n    | string\n    | ((props: {\n        isActive: boolean;\n        isPending: boolean;\n      }) => string | undefined);\n  end?: boolean;\n  style?:\n    | React.CSSProperties\n    | ((props: {\n        isActive: boolean;\n        isPending: boolean;\n      }) => React.CSSProperties | undefined);\n}\n\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nexport const NavLink = React.forwardRef<HTMLAnchorElement, NavLinkProps>(\n  function NavLinkWithRef(\n    {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      children,\n      ...rest\n    },\n    ref\n  ) {\n    let path = useResolvedPath(to, { relative: rest.relative });\n    let location = useLocation();\n    let routerState = React.useContext(DataRouterStateContext);\n\n    let toPathname = path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname =\n      routerState && routerState.navigation && routerState.navigation.location\n        ? routerState.navigation.location.pathname\n        : null;\n\n    if (!caseSensitive) {\n      locationPathname = locationPathname.toLowerCase();\n      nextLocationPathname = nextLocationPathname\n        ? nextLocationPathname.toLowerCase()\n        : null;\n      toPathname = toPathname.toLowerCase();\n    }\n\n    let isActive =\n      locationPathname === toPathname ||\n      (!end &&\n        locationPathname.startsWith(toPathname) &&\n        locationPathname.charAt(toPathname.length) === \"/\");\n\n    let isPending =\n      nextLocationPathname != null &&\n      (nextLocationPathname === toPathname ||\n        (!end &&\n          nextLocationPathname.startsWith(toPathname) &&\n          nextLocationPathname.charAt(toPathname.length) === \"/\"));\n\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n\n    let className: string | undefined;\n    if (typeof classNameProp === \"function\") {\n      className = classNameProp({ isActive, isPending });\n    } else {\n      // If the className prop is not a function, we use a default `active`\n      // class for <NavLink />s that are active. In v5 `active` was the default\n      // value for `activeClassName`, but we are removing that API and can still\n      // use the old default behavior for a cleaner upgrade path and keep the\n      // simple styling rules working as they currently do.\n      className = [\n        classNameProp,\n        isActive ? \"active\" : null,\n        isPending ? \"pending\" : null,\n      ]\n        .filter(Boolean)\n        .join(\" \");\n    }\n\n    let style =\n      typeof styleProp === \"function\"\n        ? styleProp({ isActive, isPending })\n        : styleProp;\n\n    return (\n      <Link\n        {...rest}\n        aria-current={ariaCurrent}\n        className={className}\n        ref={ref}\n        style={style}\n        to={to}\n      >\n        {typeof children === \"function\"\n          ? children({ isActive, isPending })\n          : children}\n      </Link>\n    );\n  }\n);\n\nif (__DEV__) {\n  NavLink.displayName = \"NavLink\";\n}\n\nexport interface FormProps extends React.FormHTMLAttributes<HTMLFormElement> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   */\n  method?: FormMethod;\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n\n  /**\n   * Determines whether the form action is relative to the route hierarchy or\n   * the pathname.  Use this if you want to opt out of navigating the route\n   * hierarchy and want to instead route based on /-delimited URL segments\n   */\n  relative?: RelativeRoutingType;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not do anything.\n   */\n  onSubmit?: React.FormEventHandler<HTMLFormElement>;\n}\n\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nexport const Form = React.forwardRef<HTMLFormElement, FormProps>(\n  (props, ref) => {\n    return <FormImpl {...props} ref={ref} />;\n  }\n);\n\nif (__DEV__) {\n  Form.displayName = \"Form\";\n}\n\ntype HTMLSubmitEvent = React.BaseSyntheticEvent<\n  SubmitEvent,\n  Event,\n  HTMLFormElement\n>;\n\ntype HTMLFormSubmitter = HTMLButtonElement | HTMLInputElement;\n\ninterface FormImplProps extends FormProps {\n  fetcherKey?: string;\n  routeId?: string;\n}\n\nconst FormImpl = React.forwardRef<HTMLFormElement, FormImplProps>(\n  (\n    {\n      reloadDocument,\n      replace,\n      method = defaultMethod,\n      action,\n      onSubmit,\n      fetcherKey,\n      routeId,\n      relative,\n      ...props\n    },\n    forwardedRef\n  ) => {\n    let submit = useSubmitImpl(fetcherKey, routeId);\n    let formMethod: FormMethod =\n      method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let formAction = useFormAction(action, { relative });\n    let submitHandler: React.FormEventHandler<HTMLFormElement> = (event) => {\n      onSubmit && onSubmit(event);\n      if (event.defaultPrevented) return;\n      event.preventDefault();\n\n      let submitter = (event as unknown as HTMLSubmitEvent).nativeEvent\n        .submitter as HTMLFormSubmitter | null;\n\n      submit(submitter || event.currentTarget, { method, replace, relative });\n    };\n\n    return (\n      <form\n        ref={forwardedRef}\n        method={formMethod}\n        action={formAction}\n        onSubmit={reloadDocument ? onSubmit : submitHandler}\n        {...props}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  Form.displayName = \"Form\";\n}\n\ninterface ScrollRestorationProps {\n  getKey?: GetScrollRestorationKeyFunction;\n  storageKey?: string;\n}\n\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\nexport function ScrollRestoration({\n  getKey,\n  storageKey,\n}: ScrollRestorationProps) {\n  useScrollRestoration({ getKey, storageKey });\n  return null;\n}\n\nif (__DEV__) {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\n\nenum DataRouterHook {\n  UseScrollRestoration = \"useScrollRestoration\",\n  UseSubmitImpl = \"useSubmitImpl\",\n  UseFetcher = \"useFetcher\",\n}\n\nenum DataRouterStateHook {\n  UseFetchers = \"useFetchers\",\n  UseScrollRestoration = \"useScrollRestoration\",\n}\n\nfunction getDataRouterConsoleError(\n  hookName: DataRouterHook | DataRouterStateHook\n) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\n\nfunction useDataRouterContext(hookName: DataRouterHook) {\n  let ctx = React.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError(hookName));\n  return ctx;\n}\n\nfunction useDataRouterState(hookName: DataRouterStateHook) {\n  let state = React.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError(hookName));\n  return state;\n}\n\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nexport function useLinkClickHandler<E extends Element = HTMLAnchorElement>(\n  to: To,\n  {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n  }: {\n    target?: React.HTMLAttributeAnchorTarget;\n    replace?: boolean;\n    state?: any;\n    preventScrollReset?: boolean;\n    relative?: RelativeRoutingType;\n  } = {}\n): (event: React.MouseEvent<E, MouseEvent>) => void {\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, { relative });\n\n  return React.useCallback(\n    (event: React.MouseEvent<E, MouseEvent>) => {\n      if (shouldProcessLinkClick(event, target)) {\n        event.preventDefault();\n\n        // If the URL hasn't changed, a regular <a> will do a replace instead of\n        // a push, so do the same here unless the replace prop is explicitly set\n        let replace =\n          replaceProp !== undefined\n            ? replaceProp\n            : createPath(location) === createPath(path);\n\n        navigate(to, { replace, state, preventScrollReset, relative });\n      }\n    },\n    [\n      location,\n      navigate,\n      path,\n      replaceProp,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      relative,\n    ]\n  );\n}\n\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nexport function useSearchParams(\n  defaultInit?: URLSearchParamsInit\n): [URLSearchParams, SetURLSearchParams] {\n  warning(\n    typeof URLSearchParams !== \"undefined\",\n    `You cannot use the \\`useSearchParams\\` hook in a browser that does not ` +\n      `support the URLSearchParams API. If you need to support Internet ` +\n      `Explorer 11, we recommend you load a polyfill such as ` +\n      `https://github.com/ungap/url-search-params\\n\\n` +\n      `If you're unsure how to load polyfills, we recommend you check out ` +\n      `https://polyfill.io/v3/ which provides some recommendations about how ` +\n      `to load polyfills only for users that need them, instead of for every ` +\n      `user.`\n  );\n\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n\n  let location = useLocation();\n  let searchParams = React.useMemo(\n    () =>\n      getSearchParamsForLocation(\n        location.search,\n        defaultSearchParamsRef.current\n      ),\n    [location.search]\n  );\n\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback<SetURLSearchParams>(\n    (nextInit, navigateOptions) => {\n      const newSearchParams = createSearchParams(\n        typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit\n      );\n      navigate(\"?\" + newSearchParams, navigateOptions);\n    },\n    [navigate, searchParams]\n  );\n\n  return [searchParams, setSearchParams];\n}\n\ntype SetURLSearchParams = (\n  nextInit?:\n    | URLSearchParamsInit\n    | ((prev: URLSearchParams) => URLSearchParamsInit),\n  navigateOpts?: NavigateOptions\n) => void;\n\ntype SubmitTarget =\n  | HTMLFormElement\n  | HTMLButtonElement\n  | HTMLInputElement\n  | FormData\n  | URLSearchParams\n  | { [name: string]: string }\n  | null;\n\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\nexport interface SubmitFunction {\n  (\n    /**\n     * Specifies the `<form>` to be submitted to the server, a specific\n     * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n     * arbitrary data to submit.\n     *\n     * Note: When using a `<button>` its `name` and `value` will also be\n     * included in the form data that is submitted.\n     */\n    target: SubmitTarget,\n\n    /**\n     * Options that override the `<form>`'s own attributes. Required when\n     * submitting arbitrary data without a backing `<form>`.\n     */\n    options?: SubmitOptions\n  ): void;\n}\n\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nexport function useSubmit(): SubmitFunction {\n  return useSubmitImpl();\n}\n\nfunction useSubmitImpl(fetcherKey?: string, routeId?: string): SubmitFunction {\n  let { router } = useDataRouterContext(DataRouterHook.UseSubmitImpl);\n  let defaultAction = useFormAction();\n\n  return React.useCallback(\n    (target, options = {}) => {\n      if (typeof document === \"undefined\") {\n        throw new Error(\n          \"You are calling submit during the server render. \" +\n            \"Try calling submit within a `useEffect` or callback instead.\"\n        );\n      }\n\n      let { method, encType, formData, url } = getFormSubmissionInfo(\n        target,\n        defaultAction,\n        options\n      );\n\n      let href = url.pathname + url.search;\n      let opts = {\n        replace: options.replace,\n        formData,\n        formMethod: method as FormMethod,\n        formEncType: encType as FormEncType,\n      };\n      if (fetcherKey) {\n        invariant(routeId != null, \"No routeId available for useFetcher()\");\n        router.fetch(fetcherKey, routeId, href, opts);\n      } else {\n        router.navigate(href, opts);\n      }\n    },\n    [defaultAction, router, fetcherKey, routeId]\n  );\n}\n\nexport function useFormAction(\n  action?: string,\n  { relative }: { relative?: RelativeRoutingType } = {}\n): string {\n  let { basename } = React.useContext(NavigationContext);\n  let routeContext = React.useContext(RouteContext);\n  invariant(routeContext, \"useFormAction must be used inside a RouteContext\");\n\n  let [match] = routeContext.matches.slice(-1);\n  let resolvedAction = action ?? \".\";\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  let path = { ...useResolvedPath(resolvedAction, { relative }) };\n\n  // Previously we set the default action to \".\". The problem with this is that\n  // `useResolvedPath(\".\")` excludes search params and the hash of the resolved\n  // URL. This is the intended behavior of when \".\" is specifically provided as\n  // the form action, but inconsistent w/ browsers when the action is omitted.\n  // https://github.com/remix-run/remix/issues/927\n  let location = useLocation();\n  if (action == null) {\n    // Safe to write to these directly here since if action was undefined, we\n    // would have called useResolvedPath(\".\") which will never include a search\n    // or hash\n    path.search = location.search;\n    path.hash = location.hash;\n\n    // When grabbing search params from the URL, remove the automatically\n    // inserted ?index param so we match the useResolvedPath search behavior\n    // which would not include ?index\n    if (match.route.index) {\n      let params = new URLSearchParams(path.search);\n      params.delete(\"index\");\n      path.search = params.toString() ? `?${params.toString()}` : \"\";\n    }\n  }\n\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search\n      ? path.search.replace(/^\\?/, \"?index&\")\n      : \"?index\";\n  }\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== \"/\") {\n    path.pathname =\n      path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n\n  return createPath(path);\n}\n\nfunction createFetcherForm(fetcherKey: string, routeId: string) {\n  let FetcherForm = React.forwardRef<HTMLFormElement, FormProps>(\n    (props, ref) => {\n      return (\n        <FormImpl\n          {...props}\n          ref={ref}\n          fetcherKey={fetcherKey}\n          routeId={routeId}\n        />\n      );\n    }\n  );\n  if (__DEV__) {\n    FetcherForm.displayName = \"fetcher.Form\";\n  }\n  return FetcherForm;\n}\n\nlet fetcherId = 0;\n\nexport type FetcherWithComponents<TData> = Fetcher<TData> & {\n  Form: ReturnType<typeof createFetcherForm>;\n  submit: (\n    target: SubmitTarget,\n    // Fetchers cannot replace because they are not navigation events\n    options?: Omit<SubmitOptions, \"replace\">\n  ) => void;\n  load: (href: string) => void;\n};\n\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nexport function useFetcher<TData = any>(): FetcherWithComponents<TData> {\n  let { router } = useDataRouterContext(DataRouterHook.UseFetcher);\n\n  let route = React.useContext(RouteContext);\n  invariant(route, `useFetcher must be used inside a RouteContext`);\n\n  let routeId = route.matches[route.matches.length - 1]?.route.id;\n  invariant(\n    routeId != null,\n    `useFetcher can only be used on routes that contain a unique \"id\"`\n  );\n\n  let [fetcherKey] = React.useState(() => String(++fetcherId));\n  let [Form] = React.useState(() => {\n    invariant(routeId, `No routeId available for fetcher.Form()`);\n    return createFetcherForm(fetcherKey, routeId);\n  });\n  let [load] = React.useState(() => (href: string) => {\n    invariant(router, \"No router available for fetcher.load()\");\n    invariant(routeId, \"No routeId available for fetcher.load()\");\n    router.fetch(fetcherKey, routeId, href);\n  });\n  let submit = useSubmitImpl(fetcherKey, routeId);\n\n  let fetcher = router.getFetcher<TData>(fetcherKey);\n\n  let fetcherWithComponents = React.useMemo(\n    () => ({\n      Form,\n      submit,\n      load,\n      ...fetcher,\n    }),\n    [fetcher, Form, submit, load]\n  );\n\n  React.useEffect(() => {\n    // Is this busted when the React team gets real weird and calls effects\n    // twice on mount?  We really just need to garbage collect here when this\n    // fetcher is no longer around.\n    return () => {\n      if (!router) {\n        console.warn(`No fetcher available to clean up from useFetcher()`);\n        return;\n      }\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n\n  return fetcherWithComponents;\n}\n\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nexport function useFetchers(): Fetcher[] {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return [...state.fetchers.values()];\n}\n\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions: Record<string, number> = {};\n\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration({\n  getKey,\n  storageKey,\n}: {\n  getKey?: GetScrollRestorationKeyFunction;\n  storageKey?: string;\n} = {}) {\n  let { router } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let { restoreScrollPosition, preventScrollReset } = useDataRouterState(\n    DataRouterStateHook.UseScrollRestoration\n  );\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n\n  // Trigger manual scroll restoration while we're active\n  React.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n\n  // Save positions on unload\n  useBeforeUnload(\n    React.useCallback(() => {\n      if (navigation.state === \"idle\") {\n        let key = (getKey ? getKey(location, matches) : null) || location.key;\n        savedScrollPositions[key] = window.scrollY;\n      }\n      sessionStorage.setItem(\n        storageKey || SCROLL_RESTORATION_STORAGE_KEY,\n        JSON.stringify(savedScrollPositions)\n      );\n      window.history.scrollRestoration = \"auto\";\n    }, [storageKey, getKey, navigation.state, location, matches])\n  );\n\n  // Read in any saved scroll locations\n  React.useLayoutEffect(() => {\n    try {\n      let sessionPositions = sessionStorage.getItem(\n        storageKey || SCROLL_RESTORATION_STORAGE_KEY\n      );\n      if (sessionPositions) {\n        savedScrollPositions = JSON.parse(sessionPositions);\n      }\n    } catch (e) {\n      // no-op, use default empty object\n    }\n  }, [storageKey]);\n\n  // Enable scroll restoration in the router\n  React.useLayoutEffect(() => {\n    let disableScrollRestoration = router?.enableScrollRestoration(\n      savedScrollPositions,\n      () => window.scrollY,\n      getKey\n    );\n    return () => disableScrollRestoration && disableScrollRestoration();\n  }, [router, getKey]);\n\n  // Restore scrolling when state.restoreScrollPosition changes\n  React.useLayoutEffect(() => {\n    // Explicit false means don't do anything (used for submissions)\n    if (restoreScrollPosition === false) {\n      return;\n    }\n\n    // been here before, scroll to it\n    if (typeof restoreScrollPosition === \"number\") {\n      window.scrollTo(0, restoreScrollPosition);\n      return;\n    }\n\n    // try to scroll to the hash\n    if (location.hash) {\n      let el = document.getElementById(location.hash.slice(1));\n      if (el) {\n        el.scrollIntoView();\n        return;\n      }\n    }\n\n    // Opt out of scroll reset if this link requested it\n    if (preventScrollReset === true) {\n      return;\n    }\n\n    // otherwise go to the top on new locations\n    window.scrollTo(0, 0);\n  }, [location, restoreScrollPosition, preventScrollReset]);\n}\n\nfunction useBeforeUnload(callback: () => any): void {\n  React.useEffect(() => {\n    window.addEventListener(\"beforeunload\", callback);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback);\n    };\n  }, [callback]);\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Utils\n////////////////////////////////////////////////////////////////////////////////\n\nfunction warning(cond: boolean, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n//#endregion\n","import type { FormEncType, FormMethod } from \"@remix-run/router\";\nimport type { RelativeRoutingType } from \"react-router\";\n\nexport const defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\n\nexport function isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\n\nexport function isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\n\nexport function isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\n\nexport function isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n\ntype LimitedMouseEvent = Pick<\n  MouseEvent,\n  \"button\" | \"metaKey\" | \"altKey\" | \"ctrlKey\" | \"shiftKey\"\n>;\n\nfunction isModifiedEvent(event: LimitedMouseEvent) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nexport function shouldProcessLinkClick(\n  event: LimitedMouseEvent,\n  target?: string\n) {\n  return (\n    event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n  );\n}\n\nexport type ParamKeyValuePair = [string, string];\n\nexport type URLSearchParamsInit =\n  | string\n  | ParamKeyValuePair[]\n  | Record<string, string | string[]>\n  | URLSearchParams;\n\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nexport function createSearchParams(\n  init: URLSearchParamsInit = \"\"\n): URLSearchParams {\n  return new URLSearchParams(\n    typeof init === \"string\" ||\n    Array.isArray(init) ||\n    init instanceof URLSearchParams\n      ? init\n      : Object.keys(init).reduce((memo, key) => {\n          let value = init[key];\n          return memo.concat(\n            Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]\n          );\n        }, [] as ParamKeyValuePair[])\n  );\n}\n\nexport function getSearchParamsForLocation(\n  locationSearch: string,\n  defaultSearchParams: URLSearchParams\n) {\n  let searchParams = createSearchParams(locationSearch);\n\n  for (let key of defaultSearchParams.keys()) {\n    if (!searchParams.has(key)) {\n      defaultSearchParams.getAll(key).forEach((value) => {\n        searchParams.append(key, value);\n      });\n    }\n  }\n\n  return searchParams;\n}\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n\n  /**\n   * Determines whether the form action is relative to the route hierarchy or\n   * the pathname.  Use this if you want to opt out of navigating the route\n   * hierarchy and want to instead route based on /-delimited URL segments\n   */\n  relative?: RelativeRoutingType;\n}\n\nexport function getFormSubmissionInfo(\n  target:\n    | HTMLFormElement\n    | HTMLButtonElement\n    | HTMLInputElement\n    | FormData\n    | URLSearchParams\n    | { [name: string]: string }\n    | null,\n  defaultAction: string,\n  options: SubmitOptions\n): {\n  url: URL;\n  method: string;\n  encType: string;\n  formData: FormData;\n} {\n  let method: string;\n  let action: string;\n  let encType: string;\n  let formData: FormData;\n\n  if (isFormElement(target)) {\n    let submissionTrigger: HTMLButtonElement | HTMLInputElement = (\n      options as any\n    ).submissionTrigger;\n\n    method = options.method || target.getAttribute(\"method\") || defaultMethod;\n    action = options.action || target.getAttribute(\"action\") || defaultAction;\n    encType =\n      options.encType || target.getAttribute(\"enctype\") || defaultEncType;\n\n    formData = new FormData(target);\n\n    if (submissionTrigger && submissionTrigger.name) {\n      formData.append(submissionTrigger.name, submissionTrigger.value);\n    }\n  } else if (\n    isButtonElement(target) ||\n    (isInputElement(target) &&\n      (target.type === \"submit\" || target.type === \"image\"))\n  ) {\n    let form = target.form;\n\n    if (form == null) {\n      throw new Error(\n        `Cannot submit a <button> or <input type=\"submit\"> without a <form>`\n      );\n    }\n\n    // <button>/<input type=\"submit\"> may override attributes of <form>\n\n    method =\n      options.method ||\n      target.getAttribute(\"formmethod\") ||\n      form.getAttribute(\"method\") ||\n      defaultMethod;\n    action =\n      options.action ||\n      target.getAttribute(\"formaction\") ||\n      form.getAttribute(\"action\") ||\n      defaultAction;\n    encType =\n      options.encType ||\n      target.getAttribute(\"formenctype\") ||\n      form.getAttribute(\"enctype\") ||\n      defaultEncType;\n\n    formData = new FormData(form);\n\n    // Include name + value from a <button>, appending in case the button name\n    // matches an existing input name\n    if (target.name) {\n      formData.append(target.name, target.value);\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\n      `Cannot submit element that is not <form>, <button>, or ` +\n        `<input type=\"submit|image\">`\n    );\n  } else {\n    method = options.method || defaultMethod;\n    action = options.action || defaultAction;\n    encType = options.encType || defaultEncType;\n\n    if (target instanceof FormData) {\n      formData = target;\n    } else {\n      formData = new FormData();\n\n      if (target instanceof URLSearchParams) {\n        for (let [name, value] of target) {\n          formData.append(name, value);\n        }\n      } else if (target != null) {\n        for (let name of Object.keys(target)) {\n          formData.append(name, target[name]);\n        }\n      }\n    }\n  }\n\n  let { protocol, host } = window.location;\n  let url = new URL(action, `${protocol}//${host}`);\n\n  return { url, method, encType, formData };\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as React from \"react\";\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction isPolyfill(x: any, y: any) {\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare\n  );\n}\n\nconst is: (x: any, y: any) => boolean =\n  typeof Object.is === \"function\" ? Object.is : isPolyfill;\n\n// Intentionally not using named imports because Rollup uses dynamic\n// dispatch for CommonJS interop named imports.\nconst { useState, useEffect, useLayoutEffect, useDebugValue } = React;\n\nlet didWarnOld18Alpha = false;\nlet didWarnUncachedGetSnapshot = false;\n\n// Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\nexport function useSyncExternalStore<T>(\n  subscribe: (fn: () => void) => () => void,\n  getSnapshot: () => T,\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  getServerSnapshot?: () => T\n): T {\n  if (__DEV__) {\n    if (!didWarnOld18Alpha) {\n      if (\"startTransition\" in React) {\n        didWarnOld18Alpha = true;\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that \" +\n            \"does not support useSyncExternalStore. The \" +\n            \"use-sync-external-store shim will not work correctly. Upgrade \" +\n            \"to a newer pre-release.\"\n        );\n      }\n    }\n  }\n\n  // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n  const value = getSnapshot();\n  if (__DEV__) {\n    if (!didWarnUncachedGetSnapshot) {\n      const cachedValue = getSnapshot();\n      if (!is(value, cachedValue)) {\n        console.error(\n          \"The result of getSnapshot should be cached to avoid an infinite loop\"\n        );\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  }\n\n  // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n  const [{ inst }, forceUpdate] = useState({ inst: { value, getSnapshot } });\n\n  // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n  useLayoutEffect(() => {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot;\n\n    // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({ inst });\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [subscribe, value, getSnapshot]);\n\n  useEffect(() => {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({ inst });\n    }\n    const handleStoreChange = () => {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst });\n      }\n    };\n    // Subscribe to the store and return a clean-up function.\n    return subscribe(handleStoreChange);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [subscribe]);\n\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst: any) {\n  const latestGetSnapshot = inst.getSnapshot;\n  const prevValue = inst.value;\n  try {\n    const nextValue = latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n","/**\n * Inlined into the react-router repo since use-sync-external-store does not\n * provide a UMD-compatible package, so we need this to be able to distribute\n * UMD react-router bundles\n */\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as React from \"react\";\n\nimport { useSyncExternalStore as client } from \"./useSyncExternalStoreShimClient\";\nimport { useSyncExternalStore as server } from \"./useSyncExternalStoreShimServer\";\n\nconst canUseDOM: boolean = !!(\n  typeof window !== \"undefined\" &&\n  typeof window.document !== \"undefined\" &&\n  typeof window.document.createElement !== \"undefined\"\n);\nconst isServerEnvironment = !canUseDOM;\nconst shim = isServerEnvironment ? server : client;\n\nexport const useSyncExternalStore =\n  \"useSyncExternalStore\" in React\n    ? ((module) => module.useSyncExternalStore)(React)\n    : shim;\n","import * as React from \"react\";\nimport type {\n  AgnosticRouteMatch,\n  AgnosticIndexRouteObject,\n  AgnosticNonIndexRouteObject,\n  History,\n  Location,\n  Router,\n  StaticHandlerContext,\n  To,\n  TrackedPromise,\n} from \"@remix-run/router\";\nimport type { Action as NavigationType } from \"@remix-run/router\";\n\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nexport interface IndexRouteObject {\n  caseSensitive?: AgnosticIndexRouteObject[\"caseSensitive\"];\n  path?: AgnosticIndexRouteObject[\"path\"];\n  id?: AgnosticIndexRouteObject[\"id\"];\n  loader?: AgnosticIndexRouteObject[\"loader\"];\n  action?: AgnosticIndexRouteObject[\"action\"];\n  hasErrorBoundary?: AgnosticIndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: AgnosticIndexRouteObject[\"shouldRevalidate\"];\n  handle?: AgnosticIndexRouteObject[\"handle\"];\n  index: true;\n  children?: undefined;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n}\n\nexport interface NonIndexRouteObject {\n  caseSensitive?: AgnosticNonIndexRouteObject[\"caseSensitive\"];\n  path?: AgnosticNonIndexRouteObject[\"path\"];\n  id?: AgnosticNonIndexRouteObject[\"id\"];\n  loader?: AgnosticNonIndexRouteObject[\"loader\"];\n  action?: AgnosticNonIndexRouteObject[\"action\"];\n  hasErrorBoundary?: AgnosticNonIndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: AgnosticNonIndexRouteObject[\"shouldRevalidate\"];\n  handle?: AgnosticNonIndexRouteObject[\"handle\"];\n  index?: false;\n  children?: RouteObject[];\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n}\n\nexport type RouteObject = IndexRouteObject | NonIndexRouteObject;\n\nexport type DataRouteObject = RouteObject & {\n  children?: DataRouteObject[];\n  id: string;\n};\n\nexport interface RouteMatch<\n  ParamKey extends string = string,\n  RouteObjectType extends RouteObject = RouteObject\n> extends AgnosticRouteMatch<ParamKey, RouteObjectType> {}\n\nexport interface DataRouteMatch extends RouteMatch<string, DataRouteObject> {}\n\n// Contexts for data routers\nexport const DataStaticRouterContext =\n  React.createContext<StaticHandlerContext | null>(null);\nif (__DEV__) {\n  DataStaticRouterContext.displayName = \"DataStaticRouterContext\";\n}\n\nexport interface DataRouterContextObject extends NavigationContextObject {\n  router: Router;\n}\n\nexport const DataRouterContext =\n  React.createContext<DataRouterContextObject | null>(null);\nif (__DEV__) {\n  DataRouterContext.displayName = \"DataRouter\";\n}\n\nexport const DataRouterStateContext = React.createContext<\n  Router[\"state\"] | null\n>(null);\nif (__DEV__) {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\n\nexport const AwaitContext = React.createContext<TrackedPromise | null>(null);\nif (__DEV__) {\n  AwaitContext.displayName = \"Await\";\n}\n\nexport type RelativeRoutingType = \"route\" | \"path\";\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n}\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nexport interface Navigator {\n  createHref: History[\"createHref\"];\n  go: History[\"go\"];\n  push(to: To, state?: any, opts?: NavigateOptions): void;\n  replace(to: To, state?: any, opts?: NavigateOptions): void;\n}\n\ninterface NavigationContextObject {\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n}\n\nexport const NavigationContext = React.createContext<NavigationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  NavigationContext.displayName = \"Navigation\";\n}\n\ninterface LocationContextObject {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nexport const LocationContext = React.createContext<LocationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  LocationContext.displayName = \"Location\";\n}\n\nexport interface RouteContextObject {\n  outlet: React.ReactElement | null;\n  matches: RouteMatch[];\n}\n\nexport const RouteContext = React.createContext<RouteContextObject>({\n  outlet: null,\n  matches: [],\n});\n\nif (__DEV__) {\n  RouteContext.displayName = \"Route\";\n}\n\nexport const RouteErrorContext = React.createContext<any>(null);\n\nif (__DEV__) {\n  RouteErrorContext.displayName = \"RouteError\";\n}\n","import * as React from \"react\";\nimport type {\n  Location,\n  ParamParseKey,\n  Params,\n  Path,\n  PathMatch,\n  PathPattern,\n  Router as RemixRouter,\n  To,\n} from \"@remix-run/router\";\nimport {\n  Action as NavigationType,\n  invariant,\n  isRouteErrorResponse,\n  joinPaths,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  resolveTo,\n  warning,\n  UNSAFE_getPathContributingMatches as getPathContributingMatches,\n} from \"@remix-run/router\";\n\nimport type {\n  NavigateOptions,\n  RouteContextObject,\n  RouteMatch,\n  RouteObject,\n  DataRouteMatch,\n  RelativeRoutingType,\n} from \"./context\";\nimport {\n  DataRouterContext,\n  DataRouterStateContext,\n  LocationContext,\n  NavigationContext,\n  RouteContext,\n  RouteErrorContext,\n  AwaitContext,\n  DataStaticRouterContext,\n} from \"./context\";\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-href\n */\nexport function useHref(\n  to: To,\n  { relative }: { relative?: RelativeRoutingType } = {}\n): string {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to, { relative });\n\n  let joinedPathname = pathname;\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n  if (basename !== \"/\") {\n    joinedPathname =\n      pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-in-router-context\n */\nexport function useInRouterContext(): boolean {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-location\n */\nexport function useLocation(): Location {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-navigation-type\n */\nexport function useNavigationType(): NavigationType {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-match\n */\nexport function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n\n  let { pathname } = useLocation();\n  return React.useMemo(\n    () => matchPath<ParamKey, Path>(pattern, pathname),\n    [pathname, pattern]\n  );\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nexport interface NavigateFunction {\n  (to: To, options?: NavigateOptions): void;\n  (delta: number): void;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-navigate\n */\nexport function useNavigate(): NavigateFunction {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    getPathContributingMatches(matches).map((match) => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(\n        activeRef.current,\n        `You should call navigate() in a React.useEffect(), not when ` +\n          `your component is first rendered.`\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname,\n        options.relative === \"path\"\n      );\n\n      // If we're operating within a basename, prepend it to the pathname prior\n      // to handing off to history.  If this is a root navigation, then we\n      // navigate to the raw basename which allows the basename to have full\n      // control over the presence of a trailing slash on root links\n      if (basename !== \"/\") {\n        path.pathname =\n          path.pathname === \"/\"\n            ? basename\n            : joinPaths([basename, path.pathname]);\n      }\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state,\n        options\n      );\n    },\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n}\n\nconst OutletContext = React.createContext<unknown>(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/hooks/use-outlet-context\n */\nexport function useOutletContext<Context = unknown>(): Context {\n  return React.useContext(OutletContext) as Context;\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-outlet\n */\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-params\n */\nexport function useParams<\n  ParamsOrKey extends string | Record<string, string | undefined> = string\n>(): Readonly<\n  [ParamsOrKey] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>\n> {\n  let { matches } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-resolved-path\n */\nexport function useResolvedPath(\n  to: To,\n  { relative }: { relative?: RelativeRoutingType } = {}\n): Path {\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    getPathContributingMatches(matches).map((match) => match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () =>\n      resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname,\n        relative === \"path\"\n      ),\n    [to, routePathnamesJson, locationPathname, relative]\n  );\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-routes\n */\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string\n): React.ReactElement | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n\n  let dataRouterStateContext = React.useContext(DataRouterStateContext);\n  let { matches: parentMatches } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (__DEV__) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = (parentRoute && parentRoute.path) || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at ` +\n        `\"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the ` +\n        `parent route path has no trailing \"*\". This means if you navigate ` +\n        `deeper, the parent won't match anymore and therefore the child ` +\n        `routes will never render.\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route ` +\n        `path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n\n  let locationFromContext = useLocation();\n\n  let location;\n  if (locationArg) {\n    let parsedLocationArg =\n      typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n    invariant(\n      parentPathnameBase === \"/\" ||\n        parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, ` +\n        `the location pathname must begin with the portion of the URL pathname that was ` +\n        `matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" ` +\n        `but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname =\n    parentPathnameBase === \"/\"\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || \"/\";\n\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n\n  if (__DEV__) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n\n    warning(\n      matches == null ||\n        matches[matches.length - 1].route.element !== undefined,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element. ` +\n        `This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n\n  let renderedMatches = _renderMatches(\n    matches &&\n      matches.map((match) =>\n        Object.assign({}, match, {\n          params: Object.assign({}, parentParams, match.params),\n          pathname: joinPaths([parentPathnameBase, match.pathname]),\n          pathnameBase:\n            match.pathnameBase === \"/\"\n              ? parentPathnameBase\n              : joinPaths([parentPathnameBase, match.pathnameBase]),\n        })\n      ),\n    parentMatches,\n    dataRouterStateContext || undefined\n  );\n\n  // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n  if (locationArg && renderedMatches) {\n    return (\n      <LocationContext.Provider\n        value={{\n          location: {\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: \"default\",\n            ...location,\n          },\n          navigationType: NavigationType.Pop,\n        }}\n      >\n        {renderedMatches}\n      </LocationContext.Provider>\n    );\n  }\n\n  return renderedMatches;\n}\n\nfunction DefaultErrorElement() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error)\n    ? `${error.status} ${error.statusText}`\n    : error instanceof Error\n    ? error.message\n    : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = { padding: \"0.5rem\", backgroundColor: lightgrey };\n  let codeStyles = { padding: \"2px 4px\", backgroundColor: lightgrey };\n  return (\n    <>\n      <h2>Unhandled Thrown Error!</h2>\n      <h3 style={{ fontStyle: \"italic\" }}>{message}</h3>\n      {stack ? <pre style={preStyles}>{stack}</pre> : null}\n      <p> Hey developer </p>\n      <p>\n        You can provide a way better UX than this when your app throws errors by\n        providing your own&nbsp;\n        <code style={codeStyles}>errorElement</code> props on&nbsp;\n        <code style={codeStyles}>&lt;Route&gt;</code>\n      </p>\n    </>\n  );\n}\n\ntype RenderErrorBoundaryProps = React.PropsWithChildren<{\n  location: Location;\n  error: any;\n  component: React.ReactNode;\n}>;\n\ntype RenderErrorBoundaryState = {\n  location: Location;\n  error: any;\n};\n\nexport class RenderErrorBoundary extends React.Component<\n  RenderErrorBoundaryProps,\n  RenderErrorBoundaryState\n> {\n  constructor(props: RenderErrorBoundaryProps) {\n    super(props);\n    this.state = {\n      location: props.location,\n      error: props.error,\n    };\n  }\n\n  static getDerivedStateFromError(error: any) {\n    return { error: error };\n  }\n\n  static getDerivedStateFromProps(\n    props: RenderErrorBoundaryProps,\n    state: RenderErrorBoundaryState\n  ) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application, that will have no effect--the error page continues to display.\n    // This gives us a mechanism to recover from the error when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location) {\n      return {\n        error: props.error,\n        location: props.location,\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error || state.error,\n      location: state.location,\n    };\n  }\n\n  componentDidCatch(error: any, errorInfo: any) {\n    console.error(\n      \"React Router caught the following error during render\",\n      error,\n      errorInfo\n    );\n  }\n\n  render() {\n    return this.state.error ? (\n      <RouteErrorContext.Provider\n        value={this.state.error}\n        children={this.props.component}\n      />\n    ) : (\n      this.props.children\n    );\n  }\n}\n\ninterface RenderedRouteProps {\n  routeContext: RouteContextObject;\n  match: RouteMatch<string, RouteObject>;\n  children: React.ReactNode | null;\n}\n\nfunction RenderedRoute({ routeContext, match, children }: RenderedRouteProps) {\n  let dataStaticRouterContext = React.useContext(DataStaticRouterContext);\n\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n  if (dataStaticRouterContext && match.route.errorElement) {\n    dataStaticRouterContext._deepestRenderedBoundaryId = match.route.id;\n  }\n\n  return (\n    <RouteContext.Provider value={routeContext}>\n      {children}\n    </RouteContext.Provider>\n  );\n}\n\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] = [],\n  dataRouterState?: RemixRouter[\"state\"]\n): React.ReactElement | null {\n  if (matches == null) {\n    if (dataRouterState?.errors) {\n      // Don't bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches as DataRouteMatch[];\n    } else {\n      return null;\n    }\n  }\n\n  let renderedMatches = matches;\n\n  // If we have data errors, trim matches to the highest error boundary\n  let errors = dataRouterState?.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(\n      (m) => m.route.id && errors?.[m.route.id]\n    );\n    invariant(\n      errorIndex >= 0,\n      `Could not find a matching route for the current errors: ${errors}`\n    );\n    renderedMatches = renderedMatches.slice(\n      0,\n      Math.min(renderedMatches.length, errorIndex + 1)\n    );\n  }\n\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error = match.route.id ? errors?.[match.route.id] : null;\n    // Only data routers handle errors\n    let errorElement = dataRouterState\n      ? match.route.errorElement || <DefaultErrorElement />\n      : null;\n    let getChildren = () => (\n      <RenderedRoute\n        match={match}\n        routeContext={{\n          outlet,\n          matches: parentMatches.concat(renderedMatches.slice(0, index + 1)),\n        }}\n      >\n        {error\n          ? errorElement\n          : match.route.element !== undefined\n          ? match.route.element\n          : outlet}\n      </RenderedRoute>\n    );\n    // Only wrap in an error boundary within data router usages when we have an\n    // errorElement on this route.  Otherwise let it bubble up to an ancestor\n    // errorElement\n    return dataRouterState && (match.route.errorElement || index === 0) ? (\n      <RenderErrorBoundary\n        location={dataRouterState.location}\n        component={errorElement}\n        error={error}\n        children={getChildren()}\n      />\n    ) : (\n      getChildren()\n    );\n  }, null as React.ReactElement | null);\n}\n\nenum DataRouterHook {\n  UseRevalidator = \"useRevalidator\",\n}\n\nenum DataRouterStateHook {\n  UseLoaderData = \"useLoaderData\",\n  UseActionData = \"useActionData\",\n  UseRouteError = \"useRouteError\",\n  UseNavigation = \"useNavigation\",\n  UseRouteLoaderData = \"useRouteLoaderData\",\n  UseMatches = \"useMatches\",\n  UseRevalidator = \"useRevalidator\",\n}\n\nfunction getDataRouterConsoleError(\n  hookName: DataRouterHook | DataRouterStateHook\n) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\n\nfunction useDataRouterContext(hookName: DataRouterHook) {\n  let ctx = React.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError(hookName));\n  return ctx;\n}\n\nfunction useDataRouterState(hookName: DataRouterStateHook) {\n  let state = React.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError(hookName));\n  return state;\n}\n\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\nexport function useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nexport function useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return {\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation,\n  };\n}\n\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\nexport function useMatches() {\n  let { matches, loaderData } = useDataRouterState(\n    DataRouterStateHook.UseMatches\n  );\n  return React.useMemo(\n    () =>\n      matches.map((match) => {\n        let { pathname, params } = match;\n        // Note: This structure matches that created by createUseMatchesMatch\n        // in the @remix-run/router , so if you change this please also change\n        // that :)  Eventually we'll DRY this up\n        return {\n          id: match.route.id,\n          pathname,\n          params,\n          data: loaderData[match.route.id] as unknown,\n          handle: match.route.handle as unknown,\n        };\n      }),\n    [matches, loaderData]\n  );\n}\n\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nexport function useLoaderData(): unknown {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n\n  let route = React.useContext(RouteContext);\n  invariant(route, `useLoaderData must be used inside a RouteContext`);\n\n  let thisRoute = route.matches[route.matches.length - 1];\n  invariant(\n    thisRoute.route.id,\n    `useLoaderData can only be used on routes that contain a unique \"id\"`\n  );\n\n  return state.loaderData[thisRoute.route.id];\n}\n\n/**\n * Returns the loaderData for the given routeId\n */\nexport function useRouteLoaderData(routeId: string): unknown {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nexport function useActionData(): unknown {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n\n  let route = React.useContext(RouteContext);\n  invariant(route, `useActionData must be used inside a RouteContext`);\n\n  return Object.values(state?.actionData || {})[0];\n}\n\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * errorElement to display a proper error message.\n */\nexport function useRouteError(): unknown {\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let route = React.useContext(RouteContext);\n  let thisRoute = route.matches[route.matches.length - 1];\n\n  // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n  if (error) {\n    return error;\n  }\n\n  invariant(route, `useRouteError must be used inside a RouteContext`);\n  invariant(\n    thisRoute.route.id,\n    `useRouteError can only be used on routes that contain a unique \"id\"`\n  );\n\n  // Otherwise look for errors from our data router state\n  return state.errors?.[thisRoute.route.id];\n}\n\n/**\n * Returns the happy-path data from the nearest ancestor <Await /> value\n */\nexport function useAsyncValue(): unknown {\n  let value = React.useContext(AwaitContext);\n  return value?._data;\n}\n\n/**\n * Returns the error from the nearest ancestor <Await /> value\n */\nexport function useAsyncError(): unknown {\n  let value = React.useContext(AwaitContext);\n  return value?._error;\n}\n\nconst alreadyWarned: Record<string, boolean> = {};\n\nfunction warningOnce(key: string, cond: boolean, message: string) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n","import * as React from \"react\";\nimport type {\n  TrackedPromise,\n  InitialEntry,\n  Location,\n  MemoryHistory,\n  Router as RemixRouter,\n  RouterState,\n  To,\n} from \"@remix-run/router\";\nimport {\n  Action as NavigationType,\n  AbortedDeferredError,\n  createMemoryHistory,\n  invariant,\n  parsePath,\n  stripBasename,\n  warning,\n} from \"@remix-run/router\";\nimport { useSyncExternalStore as useSyncExternalStoreShim } from \"./use-sync-external-store-shim\";\n\nimport type {\n  DataRouteObject,\n  IndexRouteObject,\n  RouteMatch,\n  RouteObject,\n  Navigator,\n  NonIndexRouteObject,\n  RelativeRoutingType,\n} from \"./context\";\nimport {\n  LocationContext,\n  NavigationContext,\n  DataRouterContext,\n  DataRouterStateContext,\n  AwaitContext,\n} from \"./context\";\nimport {\n  useAsyncValue,\n  useInRouterContext,\n  useNavigate,\n  useOutlet,\n  useRoutes,\n  _renderMatches,\n} from \"./hooks\";\n\nexport interface RouterProviderProps {\n  fallbackElement?: React.ReactNode;\n  router: RemixRouter;\n}\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nexport function RouterProvider({\n  fallbackElement,\n  router,\n}: RouterProviderProps): React.ReactElement {\n  // Sync router state to our component state to force re-renders\n  let state: RouterState = useSyncExternalStoreShim(\n    router.subscribe,\n    () => router.state,\n    // We have to provide this so React@18 doesn't complain during hydration,\n    // but we pass our serialized hydration data into the router so state here\n    // is already synced with what the server saw\n    () => router.state\n  );\n\n  let navigator = React.useMemo((): Navigator => {\n    return {\n      createHref: router.createHref,\n      go: (n) => router.navigate(n),\n      push: (to, state, opts) =>\n        router.navigate(to, {\n          state,\n          preventScrollReset: opts?.preventScrollReset,\n        }),\n      replace: (to, state, opts) =>\n        router.navigate(to, {\n          replace: true,\n          state,\n          preventScrollReset: opts?.preventScrollReset,\n        }),\n    };\n  }, [router]);\n\n  let basename = router.basename || \"/\";\n\n  return (\n    <DataRouterContext.Provider\n      value={{\n        router,\n        navigator,\n        static: false,\n        // Do we need this?\n        basename,\n      }}\n    >\n      <DataRouterStateContext.Provider value={state}>\n        <Router\n          basename={router.basename}\n          location={router.state.location}\n          navigationType={router.state.historyAction}\n          navigator={navigator}\n        >\n          {router.state.initialized ? <Routes /> : fallbackElement}\n        </Router>\n      </DataRouterStateContext.Provider>\n    </DataRouterContext.Provider>\n  );\n}\n\nexport interface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/routers/memory-router\n */\nexport function MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex,\n}: MemoryRouterProps): React.ReactElement {\n  let historyRef = React.useRef<MemoryHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true,\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n  relative?: RelativeRoutingType;\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/components/navigate\n */\nexport function Navigate({\n  to,\n  replace,\n  state,\n  relative,\n}: NavigateProps): null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !React.useContext(NavigationContext).static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  let dataRouterState = React.useContext(DataRouterStateContext);\n  let navigate = useNavigate();\n\n  React.useEffect(() => {\n    // Avoid kicking off multiple navigations if we're in the middle of a\n    // data-router navigation, since components get re-rendered when we enter\n    // a submitting/loading state\n    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n      return;\n    }\n    navigate(to, { replace, state, relative });\n  });\n\n  return null;\n}\n\nexport interface OutletProps {\n  context?: unknown;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/components/outlet\n */\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport interface PathRouteProps {\n  caseSensitive?: NonIndexRouteObject[\"caseSensitive\"];\n  path?: NonIndexRouteObject[\"path\"];\n  id?: NonIndexRouteObject[\"id\"];\n  loader?: NonIndexRouteObject[\"loader\"];\n  action?: NonIndexRouteObject[\"action\"];\n  hasErrorBoundary?: NonIndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: NonIndexRouteObject[\"shouldRevalidate\"];\n  handle?: NonIndexRouteObject[\"handle\"];\n  index?: false;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n}\n\nexport interface LayoutRouteProps extends PathRouteProps {}\n\nexport interface IndexRouteProps {\n  caseSensitive?: IndexRouteObject[\"caseSensitive\"];\n  path?: IndexRouteObject[\"path\"];\n  id?: IndexRouteObject[\"id\"];\n  loader?: IndexRouteObject[\"loader\"];\n  action?: IndexRouteObject[\"action\"];\n  hasErrorBoundary?: IndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: IndexRouteObject[\"shouldRevalidate\"];\n  handle?: IndexRouteObject[\"handle\"];\n  index: true;\n  children?: undefined;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n}\n\nexport type RouteProps = PathRouteProps | LayoutRouteProps | IndexRouteProps;\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/components/route\n */\nexport function Route(_props: RouteProps): React.ReactElement | null {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\n\nexport interface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/routers/router\n */\nexport function Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = NavigationType.Pop,\n  navigator,\n  static: staticProp = false,\n}: RouterProps): React.ReactElement | null {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You should never have more than one in your app.`\n  );\n\n  // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\",\n  } = locationProp;\n\n  let location = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key,\n    };\n  }, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL ` +\n      `\"${pathname}${search}${hash}\" because it does not start with the ` +\n      `basename, so the <Router> won't render anything.`\n  );\n\n  if (location == null) {\n    return null;\n  }\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider\n        children={children}\n        value={{ location, navigationType }}\n      />\n    </NavigationContext.Provider>\n  );\n}\n\nexport interface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/components/routes\n */\nexport function Routes({\n  children,\n  location,\n}: RoutesProps): React.ReactElement | null {\n  let dataRouterContext = React.useContext(DataRouterContext);\n  // When in a DataRouterContext _without_ children, we use the router routes\n  // directly.  If we have children, then we're in a descendant tree and we\n  // need to use child routes.\n  let routes =\n    dataRouterContext && !children\n      ? (dataRouterContext.router.routes as DataRouteObject[])\n      : createRoutesFromChildren(children);\n  return useRoutes(routes, location);\n}\n\nexport interface AwaitResolveRenderFunction {\n  (data: Awaited<any>): React.ReactElement;\n}\n\nexport interface AwaitProps {\n  children: React.ReactNode | AwaitResolveRenderFunction;\n  errorElement?: React.ReactNode;\n  resolve: TrackedPromise | any;\n}\n\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nexport function Await({ children, errorElement, resolve }: AwaitProps) {\n  return (\n    <AwaitErrorBoundary resolve={resolve} errorElement={errorElement}>\n      <ResolveAwait>{children}</ResolveAwait>\n    </AwaitErrorBoundary>\n  );\n}\n\ntype AwaitErrorBoundaryProps = React.PropsWithChildren<{\n  errorElement?: React.ReactNode;\n  resolve: TrackedPromise | any;\n}>;\n\ntype AwaitErrorBoundaryState = {\n  error: any;\n};\n\nenum AwaitRenderStatus {\n  pending,\n  success,\n  error,\n}\n\nconst neverSettledPromise = new Promise(() => {});\n\nclass AwaitErrorBoundary extends React.Component<\n  AwaitErrorBoundaryProps,\n  AwaitErrorBoundaryState\n> {\n  constructor(props: AwaitErrorBoundaryProps) {\n    super(props);\n    this.state = { error: null };\n  }\n\n  static getDerivedStateFromError(error: any) {\n    return { error };\n  }\n\n  componentDidCatch(error: any, errorInfo: any) {\n    console.error(\n      \"<Await> caught the following error during render\",\n      error,\n      errorInfo\n    );\n  }\n\n  render() {\n    let { children, errorElement, resolve } = this.props;\n\n    let promise: TrackedPromise | null = null;\n    let status: AwaitRenderStatus = AwaitRenderStatus.pending;\n\n    if (!(resolve instanceof Promise)) {\n      // Didn't get a promise - provide as a resolved promise\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_data\", { get: () => resolve });\n    } else if (this.state.error) {\n      // Caught a render error, provide it as a rejected promise\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_error\", { get: () => renderError });\n    } else if ((resolve as TrackedPromise)._tracked) {\n      // Already tracked promise - check contents\n      promise = resolve;\n      status =\n        promise._error !== undefined\n          ? AwaitRenderStatus.error\n          : promise._data !== undefined\n          ? AwaitRenderStatus.success\n          : AwaitRenderStatus.pending;\n    } else {\n      // Raw (untracked) promise - track it\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", { get: () => true });\n      promise = resolve.then(\n        (data: any) =>\n          Object.defineProperty(resolve, \"_data\", { get: () => data }),\n        (error: any) =>\n          Object.defineProperty(resolve, \"_error\", { get: () => error })\n      );\n    }\n\n    if (\n      status === AwaitRenderStatus.error &&\n      promise._error instanceof AbortedDeferredError\n    ) {\n      // Freeze the UI by throwing a never resolved promise\n      throw neverSettledPromise;\n    }\n\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      // No errorElement, throw to the nearest route-level error boundary\n      throw promise._error;\n    }\n\n    if (status === AwaitRenderStatus.error) {\n      // Render via our errorElement\n      return <AwaitContext.Provider value={promise} children={errorElement} />;\n    }\n\n    if (status === AwaitRenderStatus.success) {\n      // Render children with resolved value\n      return <AwaitContext.Provider value={promise} children={children} />;\n    }\n\n    // Throw to the suspense boundary\n    throw promise;\n  }\n}\n\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n */\nfunction ResolveAwait({\n  children,\n}: {\n  children: React.ReactNode | AwaitResolveRenderFunction;\n}) {\n  let data = useAsyncValue();\n  if (typeof children === \"function\") {\n    return children(data);\n  }\n  return <>{children}</>;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/create-routes-from-children\n */\nexport function createRoutesFromChildren(\n  children: React.ReactNode,\n  parentPath: number[] = []\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, (element, index) => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children, parentPath)\n      );\n      return;\n    }\n\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    invariant(\n      !element.props.index || !element.props.children,\n      \"An index route cannot have child routes.\"\n    );\n\n    let treePath = [...parentPath, index];\n    let route: RouteObject = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      hasErrorBoundary: element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(\n        element.props.children,\n        treePath\n      );\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nexport function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null {\n  return _renderMatches(matches);\n}\n\n/**\n * @private\n * Walk the route tree and add hasErrorBoundary if it's not provided, so that\n * users providing manual route arrays can just specify errorElement\n */\nexport function enhanceManualRouteObjects(\n  routes: RouteObject[]\n): RouteObject[] {\n  return routes.map((route) => {\n    let routeClone = { ...route };\n    if (routeClone.hasErrorBoundary == null) {\n      routeClone.hasErrorBoundary = routeClone.errorElement != null;\n    }\n    if (routeClone.children) {\n      routeClone.children = enhanceManualRouteObjects(routeClone.children);\n    }\n    return routeClone;\n  });\n}\n","/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\n\t\t\t\t\tfor (var key in arg) {\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import * as React from \"react\";\nimport type {\n  Hash,\n  History,\n  InitialEntry,\n  Location,\n  MemoryHistory,\n  Path,\n  Pathname,\n  Search,\n  To,\n} from \"history\";\nimport {\n  Action as NavigationType,\n  createMemoryHistory,\n  parsePath,\n  createPath,\n} from \"history\";\n\nexport { parsePath, createPath, NavigationType };\nexport type { Hash, Location, Path, Pathname, Search, To };\n\nfunction invariant(cond: any, message: string): asserts cond {\n  if (!cond) throw new Error(message);\n}\n\nfunction warning(cond: any, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nconst alreadyWarned: Record<string, boolean> = {};\nfunction warningOnce(key: string, cond: boolean, message: string) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONTEXT\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nexport type Navigator = Pick<History, \"go\" | \"push\" | \"replace\" | \"createHref\">;\n\ninterface NavigationContextObject {\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n}\n\nconst NavigationContext = React.createContext<NavigationContextObject>(null!);\n\nif (__DEV__) {\n  NavigationContext.displayName = \"Navigation\";\n}\n\ninterface LocationContextObject {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nconst LocationContext = React.createContext<LocationContextObject>(null!);\n\nif (__DEV__) {\n  LocationContext.displayName = \"Location\";\n}\n\ninterface RouteContextObject {\n  outlet: React.ReactElement | null;\n  matches: RouteMatch[];\n}\n\nconst RouteContext = React.createContext<RouteContextObject>({\n  outlet: null,\n  matches: [],\n});\n\nif (__DEV__) {\n  RouteContext.displayName = \"Route\";\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// COMPONENTS\n///////////////////////////////////////////////////////////////////////////////\n\nexport interface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/api#memoryrouter\n */\nexport function MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex,\n}: MemoryRouterProps): React.ReactElement {\n  let historyRef = React.useRef<MemoryHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/api#navigate\n */\nexport function Navigate({ to, replace, state }: NavigateProps): null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !React.useContext(NavigationContext).static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  let navigate = useNavigate();\n  React.useEffect(() => {\n    navigate(to, { replace, state });\n  });\n\n  return null;\n}\n\nexport interface OutletProps {\n  context?: unknown;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/api#outlet\n */\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport interface RouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  index?: boolean;\n  path?: string;\n}\n\nexport interface PathRouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  index?: false;\n  path: string;\n}\n\nexport interface LayoutRouteProps {\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n}\n\nexport interface IndexRouteProps {\n  element?: React.ReactNode | null;\n  index: true;\n}\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#route\n */\nexport function Route(\n  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps\n): React.ReactElement | null {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\n\nexport interface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/api#router\n */\nexport function Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = NavigationType.Pop,\n  navigator,\n  static: staticProp = false,\n}: RouterProps): React.ReactElement | null {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You should never have more than one in your app.`\n  );\n\n  let basename = normalizePathname(basenameProp);\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\",\n  } = locationProp;\n\n  let location = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key,\n    };\n  }, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL ` +\n      `\"${pathname}${search}${hash}\" because it does not start with the ` +\n      `basename, so the <Router> won't render anything.`\n  );\n\n  if (location == null) {\n    return null;\n  }\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider\n        children={children}\n        value={{ location, navigationType }}\n      />\n    </NavigationContext.Provider>\n  );\n}\n\nexport interface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#routes\n */\nexport function Routes({\n  children,\n  location,\n}: RoutesProps): React.ReactElement | null {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usehref\n */\nexport function useHref(to: To): string {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to);\n\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    let toPathname = getToPathname(to);\n    let endsWithSlash = toPathname != null && toPathname.endsWith(\"/\");\n    joinedPathname =\n      pathname === \"/\"\n        ? basename + (endsWithSlash ? \"/\" : \"\")\n        : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext\n */\nexport function useInRouterContext(): boolean {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/api#uselocation\n */\nexport function useLocation(): Location {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n\n  return React.useContext(LocationContext).location;\n}\n\ntype ParamParseFailed = { failed: true };\n\ntype ParamParseSegment<Segment extends string> =\n  // Check here if there exists a forward slash in the string.\n  Segment extends `${infer LeftSegment}/${infer RightSegment}`\n    ? // If there is a forward slash, then attempt to parse each side of the\n      // forward slash.\n      ParamParseSegment<LeftSegment> extends infer LeftResult\n      ? ParamParseSegment<RightSegment> extends infer RightResult\n        ? LeftResult extends string\n          ? // If the left side is successfully parsed as a param, then check if\n            // the right side can be successfully parsed as well. If both sides\n            // can be parsed, then the result is a union of the two sides\n            // (read: \"foo\" | \"bar\").\n            RightResult extends string\n            ? LeftResult | RightResult\n            : LeftResult\n          : // If the left side is not successfully parsed as a param, then check\n          // if only the right side can be successfully parse as a param. If it\n          // can, then the result is just right, else it's a failure.\n          RightResult extends string\n          ? RightResult\n          : ParamParseFailed\n        : ParamParseFailed\n      : // If the left side didn't parse into a param, then just check the right\n      // side.\n      ParamParseSegment<RightSegment> extends infer RightResult\n      ? RightResult extends string\n        ? RightResult\n        : ParamParseFailed\n      : ParamParseFailed\n    : // If there's no forward slash, then check if this segment starts with a\n    // colon. If it does, then this is a dynamic segment, so the result is\n    // just the remainder of the string. Otherwise, it's a failure.\n    Segment extends `:${infer Remaining}`\n    ? Remaining\n    : ParamParseFailed;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\ntype ParamParseKey<Segment extends string> =\n  ParamParseSegment<Segment> extends string\n    ? ParamParseSegment<Segment>\n    : string;\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype\n */\nexport function useNavigationType(): NavigationType {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usematch\n */\nexport function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n\n  let { pathname } = useLocation();\n  return React.useMemo(\n    () => matchPath<ParamKey, Path>(pattern, pathname),\n    [pathname, pattern]\n  );\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nexport interface NavigateFunction {\n  (to: To, options?: NavigateOptions): void;\n  (delta: number): void;\n}\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigate\n */\nexport function useNavigate(): NavigateFunction {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(\n        activeRef.current,\n        `You should call navigate() in a React.useEffect(), not when ` +\n          `your component is first rendered.`\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !== \"/\") {\n        path.pathname = joinPaths([basename, path.pathname]);\n      }\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    },\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n}\n\nconst OutletContext = React.createContext<unknown>(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext\n */\nexport function useOutletContext<Context = unknown>(): Context {\n  return React.useContext(OutletContext) as Context;\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useoutlet\n */\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useparams\n */\nexport function useParams<\n  ParamsOrKey extends string | Record<string, string | undefined> = string\n>(): Readonly<\n  [ParamsOrKey] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>\n> {\n  let { matches } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */\nexport function useResolvedPath(to: To): Path {\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useroutes\n */\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string\n): React.ReactElement | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n\n  let { matches: parentMatches } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (__DEV__) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = (parentRoute && parentRoute.path) || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at ` +\n        `\"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the ` +\n        `parent route path has no trailing \"*\". This means if you navigate ` +\n        `deeper, the parent won't match anymore and therefore the child ` +\n        `routes will never render.\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route ` +\n        `path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n\n  let locationFromContext = useLocation();\n\n  let location;\n  if (locationArg) {\n    let parsedLocationArg =\n      typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n    invariant(\n      parentPathnameBase === \"/\" ||\n        parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, ` +\n        `the location pathname must begin with the portion of the URL pathname that was ` +\n        `matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" ` +\n        `but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname =\n    parentPathnameBase === \"/\"\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n\n  if (__DEV__) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n\n    warning(\n      matches == null ||\n        matches[matches.length - 1].route.element !== undefined,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element. ` +\n        `This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n\n  return _renderMatches(\n    matches &&\n      matches.map((match) =>\n        Object.assign({}, match, {\n          params: Object.assign({}, parentParams, match.params),\n          pathname: joinPaths([parentPathnameBase, match.pathname]),\n          pathnameBase:\n            match.pathnameBase === \"/\"\n              ? parentPathnameBase\n              : joinPaths([parentPathnameBase, match.pathnameBase]),\n        })\n      ),\n    parentMatches\n  );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren\n */\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, (element) => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    }\n\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    let route: RouteObject = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport interface RouteObject {\n  caseSensitive?: boolean;\n  children?: RouteObject[];\n  element?: React.ReactNode;\n  index?: boolean;\n  path?: string;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/api#generatepath\n */\nexport function generatePath(path: string, params: Params = {}): string {\n  return path\n    .replace(/:(\\w+)/g, (_, key) => {\n      invariant(params[key] != null, `Missing \":${key}\" param`);\n      return params[key]!;\n    })\n    .replace(/\\/*\\*$/, (_) =>\n      params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\")\n    );\n}\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface RouteMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObject;\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchroutes\n */\nexport function matchRoutes(\n  routes: RouteObject[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): RouteMatch[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i], pathname);\n  }\n\n  return matches;\n}\n\ninterface RouteMeta {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObject;\n}\n\ninterface RouteBranch {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta[];\n}\n\nfunction flattenRoutes(\n  routes: RouteObject[],\n  branches: RouteBranch[] = [],\n  parentsMeta: RouteMeta[] = [],\n  parentPath = \"\"\n): RouteBranch[] {\n  routes.forEach((route, index) => {\n    let meta: RouteMeta = {\n      relativePath: route.path || \"\",\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({ path, score: computeScore(path, route.index), routesMeta });\n  });\n\n  return branches;\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<ParamKey extends string = string>(\n  branch: RouteBranch,\n  pathname: string\n): RouteMatch<ParamKey>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: RouteMatch[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nexport function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null {\n  return _renderMatches(matches);\n}\n\nfunction _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] = []\n): React.ReactElement | null {\n  if (matches == null) return null;\n\n  return matches.reduceRight((outlet, match, index) => {\n    return (\n      <RouteContext.Provider\n        children={\n          match.route.element !== undefined ? match.route.element : outlet\n        }\n        value={{\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n        }}\n      />\n    );\n  }, null as React.ReactElement | null);\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchpath\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end\n      ? \"\\\\/*$\" // When matching to the end, ignore trailing slashes\n      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n        // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n        // but do not consume the character in the matched path so they can match against\n        // nested paths.\n        \"(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)\";\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/api#resolvepath\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string\n): Path {\n  let to = typeof toArg === \"string\" ? parsePath(toArg) : toArg;\n  let toPathname = toArg === \"\" || to.pathname === \"\" ? \"/\" : to.pathname;\n\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  let from: string;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original to value had one.\n  if (\n    toPathname &&\n    toPathname !== \"/\" &&\n    toPathname.endsWith(\"/\") &&\n    !path.pathname.endsWith(\"/\")\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\nfunction getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\nfunction stripBasename(pathname: string, basename: string): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  let nextChar = pathname.charAt(basename.length);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(basename.length) || \"/\";\n}\n\nconst joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\nconst normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\nconst normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\nconst normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\n///////////////////////////////////////////////////////////////////////////////\n// DANGER! PLEASE READ ME!\n// We provide these exports as an escape hatch in the event that you need any\n// routing data that we don't provide an explicit API for. With that said, we\n// want to cover your use case if we can, so if you feel the need to use these\n// we want to hear from you. Let us know what you're building and we'll do our\n// best to make sure we can support you!\n//\n// We consider these exports an implementation detail and do not guarantee\n// against any breaking changes, regardless of the semver release. Use with\n// extreme caution and only if you understand the consequences. Godspeed.\n///////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport {\n  NavigationContext as UNSAFE_NavigationContext,\n  LocationContext as UNSAFE_LocationContext,\n  RouteContext as UNSAFE_RouteContext,\n};\n","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithoutHoles = require(\"./arrayWithoutHoles.js\");\nvar iterableToArray = require(\"./iterableToArray.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableSpread = require(\"./nonIterableSpread.js\");\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["formatProdErrorMessage","code","$$observable","Symbol","observable","randomString","Math","random","toString","substring","split","join","ActionTypes","INIT","REPLACE","PROBE_UNKNOWN_ACTION","isPlainObject","obj","proto","Object","getPrototypeOf","createStore","reducer","preloadedState","enhancer","_ref2","arguments","Error","undefined","currentReducer","currentState","currentListeners","nextListeners","isDispatching","ensureCanMutateNextListeners","slice","getState","subscribe","listener","isSubscribed","push","index","indexOf","splice","dispatch","action","type","listeners","i","length","replaceReducer","nextReducer","_ref","outerSubscribe","observer","observeState","next","unsubscribe","this","legacy_createStore","combineReducers","reducers","reducerKeys","keys","finalReducers","key","process","shapeAssertionError","finalReducerKeys","forEach","assertReducerShape","e","state","hasChanged","nextState","_i","_key","previousStateForKey","nextStateForKey","bindActionCreator","actionCreator","apply","bindActionCreators","actionCreators","boundActionCreators","compose","_len","funcs","Array","arg","reduce","a","b","applyMiddleware","middlewares","store","_dispatch","middlewareAPI","chain","map","middleware","_objectSpread","createReduxStore","bag","models","model","createModelReducer","rootReducer","createRootReducer","Redux","reduxConfig","enhancers","devtoolComposer","devtoolOptions","disabled","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","composeEnhancersWithDevtools","bagInitialState","initialState","modelReducers","reducerKey","actionName","isAlreadyActionName","name","combinedReducer","payload","meta","modelBaseReducer","baseReducer","forEachPlugin","onReducer","rootReducers","mergedReducers","mergeReducers","actionRootReducer","onRootReducer","createActionDispatcher","rematch","modelName","isEffect","assign","createRematchBag","config","createNamedModel","redux","method","fn","plugins","plugin","effects","createRematchStore","createEffectsMiddleware","createMiddleware","reduxStore","rematchStore","addModel","prepareModel","enhanceModel","exposed","exposedItem","isExposedFunction","params","create","onStoreCreated","modelDispatcher","reducerName","createReducerDispatcher","effectName","bind","createEffectDispatcher","onModel","count","merge","original","extra","init","initConfig","storeName","_initConfig$redux","createConfig","Action","ResultType","createPath","pathname","search","hash","charAt","parsePath","path","parsedPath","hashIndex","substr","searchIndex","matchPath","pattern","caseSensitive","end","warning","endsWith","replace","paramNames","regexpSource","_","paramName","RegExp","compilePath","matcher","match","matchedPathname","pathnameBase","captureGroups","memo","splatValue","value","decodeURIComponent","error","safelyDecodeURIComponent","invariant","message","cond","console","warn","getInvalidPathError","char","field","dest","JSON","stringify","getPathContributingMatches","matches","filter","route","resolveTo","toArg","routePathnames","locationPathname","isPathRelative","to","includes","from","isEmptyPath","toPathname","routePathnameIndex","startsWith","toSegments","shift","fromPathname","relativePath","segments","segment","pop","resolvePathname","normalizeSearch","normalizeHash","resolvePath","hasExplicitTrailingSlash","hasCurrentTrailingSlash","joinPaths","paths","AbortedDeferredError","document","createElement","validActionMethods","Set","reactIs","require","REACT_STATICS","childContextTypes","contextType","contextTypes","defaultProps","displayName","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","propTypes","KNOWN_STATICS","prototype","caller","callee","arity","MEMO_STATICS","compare","TYPE_STATICS","getStatics","component","isMemo","ForwardRef","render","Memo","defineProperty","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","objectPrototype","module","exports","hoistNonReactStatics","targetComponent","sourceComponent","blacklist","inheritedComponent","concat","targetStatics","sourceStatics","descriptor","for","c","d","f","g","h","k","l","m","n","p","q","r","t","v","w","x","y","z","u","$$typeof","A","AsyncMode","ConcurrentMode","ContextConsumer","ContextProvider","Element","Fragment","Lazy","Portal","Profiler","StrictMode","Suspense","isAsyncMode","isConcurrentMode","isContextConsumer","isContextProvider","isElement","isForwardRef","isFragment","isLazy","isPortal","isProfiler","isStrictMode","isSuspense","isValidElementType","typeOf","SurnamePinyinData","CompoundSurnamePinyinData","PINYIN_STYLE","PINYIN_MODE","DEFAULT_OPTIONS","mode","style","heteronym","INITIALS","PHONETIC_SYMBOL","RE_PHONETIC_SYMBOL","RE_TONE2","util","Pinyin","dict","_dict","hans","options","pys","nohans","surname_pinyin","firstCharCode","words","charCodeAt","single_pinyin","compact","enumerable","configurable","han","hanCode","toFixed","py","py_cached","pinyins","hasOwnProperty","compound_surname","len","prefixIndex","result","item","ch","twowords","single_surname","word","hanA","hanB","pinyinA","convert","pinyinB","String","localeCompare","arr","pinyin","first_letter","tone","initials","$0","$1_phonetic","$1","combo2array","a1","a2","j","compact2array","isArray","combo","PINYIN_DICT","dict_combo","uncomboed","buildPinyinCache","STYLE_NORMAL","STYLE_TONE","STYLE_TONE2","STYLE_TO3NE","STYLE_INITIALS","STYLE_FIRST_LETTER","useLayoutEffect","useEffect","newBatch","batch","Link","React","ref","onClick","_ref4","relative","reloadDocument","target","preventScrollReset","rest","href","useHref","internalOnClick","_temp","replaceProp","navigate","useNavigate","location","useLocation","useResolvedPath","event","button","metaKey","altKey","ctrlKey","shiftKey","isModifiedEvent","shouldProcessLinkClick","preventDefault","useLinkClickHandler","defaultPrevented","DataRouterHook","DataRouterStateHook","is","useState","useDebugValue","checkIfSnapshotChanged","inst","latestGetSnapshot","getSnapshot","prevValue","nextValue","AwaitContext","NavigationContext","LocationContext","RouteContext","outlet","RouteErrorContext","useInRouterContext","basename","navigator","joinedPathname","createHref","routePathnamesJson","activeRef","current","parse","go","_temp2","AwaitRenderStatus","neverSettledPromise","Promise","hasOwn","classNames","classes","argType","inner","call","default","Navigate","arrayLikeToArray","__esModule","iter","iterator","TypeError","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread"],"sourceRoot":""}